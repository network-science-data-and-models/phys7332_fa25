
<!DOCTYPE html>


<html lang="en" data-content_root="../../" >

  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>Class 08: Clustering &amp; Community Detection 1 — Traditional &#8212; PHYS 7332: Network Science Data &amp; Models (Fall 2025)</title>
  
  
  
  <script data-cfasync="false">
    document.documentElement.dataset.mode = localStorage.getItem("mode") || "";
    document.documentElement.dataset.theme = localStorage.getItem("theme") || "";
  </script>
  
  <!-- Loaded before other Sphinx assets -->
  <link href="../../_static/styles/theme.css?digest=dfe6caa3a7d634c4db9b" rel="stylesheet" />
<link href="../../_static/styles/bootstrap.css?digest=dfe6caa3a7d634c4db9b" rel="stylesheet" />
<link href="../../_static/styles/pydata-sphinx-theme.css?digest=dfe6caa3a7d634c4db9b" rel="stylesheet" />

  
  <link href="../../_static/vendor/fontawesome/6.5.2/css/all.min.css?digest=dfe6caa3a7d634c4db9b" rel="stylesheet" />
  <link rel="preload" as="font" type="font/woff2" crossorigin href="../../_static/vendor/fontawesome/6.5.2/webfonts/fa-solid-900.woff2" />
<link rel="preload" as="font" type="font/woff2" crossorigin href="../../_static/vendor/fontawesome/6.5.2/webfonts/fa-brands-400.woff2" />
<link rel="preload" as="font" type="font/woff2" crossorigin href="../../_static/vendor/fontawesome/6.5.2/webfonts/fa-regular-400.woff2" />

    <link rel="stylesheet" type="text/css" href="../../_static/pygments.css?v=03e43079" />
    <link rel="stylesheet" type="text/css" href="../../_static/styles/sphinx-book-theme.css?v=eba8b062" />
    <link rel="stylesheet" type="text/css" href="../../_static/togglebutton.css?v=13237357" />
    <link rel="stylesheet" type="text/css" href="../../_static/copybutton.css?v=76b2166b" />
    <link rel="stylesheet" type="text/css" href="../../_static/mystnb.8ecb98da25f57f5357bf6f572d296f466b2cfe2517ffebfabe82451661e28f02.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/sphinx-thebe.css?v=4fa983c6" />
    <link rel="stylesheet" type="text/css" href="../../_static/sphinx-design.min.css?v=95c83b7e" />
  
  <!-- Pre-loaded scripts that we'll load fully later -->
  <link rel="preload" as="script" href="../../_static/scripts/bootstrap.js?digest=dfe6caa3a7d634c4db9b" />
<link rel="preload" as="script" href="../../_static/scripts/pydata-sphinx-theme.js?digest=dfe6caa3a7d634c4db9b" />
  <script src="../../_static/vendor/fontawesome/6.5.2/js/all.min.js?digest=dfe6caa3a7d634c4db9b"></script>

    <script src="../../_static/documentation_options.js?v=9eb32ce0"></script>
    <script src="../../_static/doctools.js?v=9a2dae69"></script>
    <script src="../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../../_static/clipboard.min.js?v=a7894cd8"></script>
    <script src="../../_static/copybutton.js?v=f281be69"></script>
    <script src="../../_static/scripts/sphinx-book-theme.js?v=887ef09a"></script>
    <script>let toggleHintShow = 'Click to show';</script>
    <script>let toggleHintHide = 'Click to hide';</script>
    <script>let toggleOpenOnPrint = 'true';</script>
    <script src="../../_static/togglebutton.js?v=4a39c7ea"></script>
    <script>var togglebuttonSelector = '.toggle, .admonition.dropdown';</script>
    <script src="../../_static/design-tabs.js?v=f930bc37"></script>
    <script>const THEBE_JS_URL = "https://unpkg.com/thebe@0.8.2/lib/index.js"; const thebe_selector = ".thebe,.cell"; const thebe_selector_input = "pre"; const thebe_selector_output = ".output, .cell_output"</script>
    <script async="async" src="../../_static/sphinx-thebe.js?v=c100c467"></script>
    <script>var togglebuttonSelector = '.toggle, .admonition.dropdown';</script>
    <script>const THEBE_JS_URL = "https://unpkg.com/thebe@0.8.2/lib/index.js"; const thebe_selector = ".thebe,.cell"; const thebe_selector_input = "pre"; const thebe_selector_output = ".output, .cell_output"</script>
    <script>DOCUMENTATION_OPTIONS.pagename = 'notebooks/class_08/class_08_communities1';</script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
    <link rel="next" title="Class 09: Clustering &amp; Community Detection 2 — Contemporary" href="../class_09/class_09_communities2.html" />
    <link rel="prev" title="Class 7: Data Science 2 — Querying SQL Tables for Network Construction" href="../class_07/class_07_creating_a_network_from_sql_tables.html" />
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <meta name="docsearch:language" content="en"/>
  </head>
  
  
  <body data-bs-spy="scroll" data-bs-target=".bd-toc-nav" data-offset="180" data-bs-root-margin="0px 0px -60%" data-default-mode="">

  
  
  <div id="pst-skip-link" class="skip-link d-print-none"><a href="#main-content">Skip to main content</a></div>
  
  <div id="pst-scroll-pixel-helper"></div>
  
  <button type="button" class="btn rounded-pill" id="pst-back-to-top">
    <i class="fa-solid fa-arrow-up"></i>Back to top</button>

  
  <input type="checkbox"
          class="sidebar-toggle"
          id="pst-primary-sidebar-checkbox"/>
  <label class="overlay overlay-primary" for="pst-primary-sidebar-checkbox"></label>
  
  <input type="checkbox"
          class="sidebar-toggle"
          id="pst-secondary-sidebar-checkbox"/>
  <label class="overlay overlay-secondary" for="pst-secondary-sidebar-checkbox"></label>
  
  <div class="search-button__wrapper">
    <div class="search-button__overlay"></div>
    <div class="search-button__search-container">
<form class="bd-search d-flex align-items-center"
      action="../../search.html"
      method="get">
  <i class="fa-solid fa-magnifying-glass"></i>
  <input type="search"
         class="form-control"
         name="q"
         id="search-input"
         placeholder="Search this book..."
         aria-label="Search this book..."
         autocomplete="off"
         autocorrect="off"
         autocapitalize="off"
         spellcheck="false"/>
  <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd>K</kbd></span>
</form></div>
  </div>

  <div class="pst-async-banner-revealer d-none">
  <aside id="bd-header-version-warning" class="d-none d-print-none" aria-label="Version warning"></aside>
</div>

  
    <header class="bd-header navbar navbar-expand-lg bd-navbar d-print-none">
    </header>
  

  <div class="bd-container">
    <div class="bd-container__inner bd-page-width">
      
      
      
      <div class="bd-sidebar-primary bd-sidebar">
        

  
  <div class="sidebar-header-items sidebar-primary__section">
    
    
    
    
  </div>
  
    <div class="sidebar-primary-items__start sidebar-primary__section">
        <div class="sidebar-primary-item">

  
    
  

<a class="navbar-brand logo" href="../../README.html">
  
  
  
  
  
  
    <p class="title logo__title">PHYS 7332: Network Science Data & Models (Fall 2025)</p>
  
</a></div>
        <div class="sidebar-primary-item">

 <script>
 document.write(`
   <button class="btn search-button-field search-button__button" title="Search" aria-label="Search" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <i class="fa-solid fa-magnifying-glass"></i>
    <span class="search-button__default-text">Search</span>
    <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd class="kbd-shortcut__modifier">K</kbd></span>
   </button>
 `);
 </script></div>
        <div class="sidebar-primary-item"><nav class="bd-links bd-docs-nav" aria-label="Main">
    <div class="bd-toc-item navbar-nav active">
        
        <ul class="nav bd-sidenav bd-sidenav__home-link">
            <li class="toctree-l1">
                <a class="reference internal" href="../../README.html">
                    PHYS 7332: Network Science Data & Models – Fall 2025
                </a>
            </li>
        </ul>
        <ul class="current nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="../class_00/class_00_github_computing_setup.html">Chapter 00: Introduction and Setup</a></li>
<li class="toctree-l1"><a class="reference internal" href="../class_01/class_01_python_refresher.html">Chapter 01: Python Refresher</a></li>
<li class="toctree-l1"><a class="reference internal" href="../class_02/class_02_networkx1.html">Chapter 02: Introduction to Networkx 1</a></li>
<li class="toctree-l1"><a class="reference internal" href="../class_03/class_03_networkx2.html">Chapter 03: Introduction to Networkx 2</a></li>
<li class="toctree-l1"><a class="reference internal" href="../class_04/class_04_distributions.html">Chapter 04: Distributions of Network Properties &amp; Centralities</a></li>
<li class="toctree-l1"><a class="reference internal" href="../class_05/class_05_scraping1.html">Chapter 05: Scraping Web Data 1 - BeautifulSoup &amp; HTML</a></li>
<li class="toctree-l1"><a class="reference internal" href="../class_06/class_06_data_science_and_sql.html">Chapter 06: Data Science 1 — Pandas, SQL, Regressions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../class_07/class_07_creating_a_network_from_sql_tables.html">Chapter 07: Data Science 2 — SQL for Network Construction</a></li>
<li class="toctree-l1 current active"><a class="current reference internal" href="#">Chapter 08: Clustering &amp; Community Detection 1 — Traditional</a></li>
<li class="toctree-l1"><a class="reference internal" href="../class_09/class_09_communities2.html">Chapter 09: Clustering &amp; Community Detection 2 — Contemporary</a></li>
<li class="toctree-l1"><a class="reference internal" href="../class_12/class_12_visualization_python.html">Chapter 12: Visualization 1 — Python and Matplotlib</a></li>
<li class="toctree-l1"><a class="reference internal" href="../class_13/class_13_visualization_python.html">Chapter 13: Visualization 2 — Advanced Python</a></li>
<li class="toctree-l1"><a class="reference internal" href="../class_14/class_14_graph_machine_learning_1.html">Chapter 14: Machine Learning 1 - General</a></li>
<li class="toctree-l1"><a class="reference internal" href="../class_15/class_15_graph_ml_2.html">Chapter 15: Machine Learning 2 - Graph Convolutional Networks</a></li>
<li class="toctree-l1"><a class="reference internal" href="../class_16/class_16_dynamics1.html">Chapter 16: Dynamics on Networks 1 — Diffusion and Random Walks</a></li>
<li class="toctree-l1"><a class="reference internal" href="../class_17/class_17_dynamics2.html">Chapter 17: Dynamics on Networks 2 — Compartmental Models</a></li>
</ul>

    </div>
</nav></div>
    </div>
  
  
  <div class="sidebar-primary-items__end sidebar-primary__section">
  </div>
  
  <div id="rtd-footer-container"></div>


      </div>
      
      <main id="main-content" class="bd-main" role="main">
        
        

<div class="sbt-scroll-pixel-helper"></div>

          <div class="bd-content">
            <div class="bd-article-container">
              
              <div class="bd-header-article d-print-none">
<div class="header-article-items header-article__inner">
  
    <div class="header-article-items__start">
      
        <div class="header-article-item"><button class="sidebar-toggle primary-toggle btn btn-sm" title="Toggle primary sidebar" data-bs-placement="bottom" data-bs-toggle="tooltip">
  <span class="fa-solid fa-bars"></span>
</button></div>
      
    </div>
  
  
    <div class="header-article-items__end">
      
        <div class="header-article-item">

<div class="article-header-buttons">





<div class="dropdown dropdown-source-buttons">
  <button class="btn dropdown-toggle" type="button" data-bs-toggle="dropdown" aria-expanded="false" aria-label="Source repositories">
    <i class="fab fa-github"></i>
  </button>
  <ul class="dropdown-menu">
      
      
      
      <li><a href="https://github.com/network-science-data-and-models/phys7332_fa25" target="_blank"
   class="btn btn-sm btn-source-repository-button dropdown-item"
   title="Source repository"
   data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fab fa-github"></i>
  </span>
<span class="btn__text-container">Repository</span>
</a>
</li>
      
      
      
      
      <li><a href="https://github.com/network-science-data-and-models/phys7332_fa25/issues/new?title=Issue%20on%20page%20%2Fnotebooks/class_08/class_08_communities1.html&body=Your%20issue%20content%20here." target="_blank"
   class="btn btn-sm btn-source-issues-button dropdown-item"
   title="Open an issue"
   data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-lightbulb"></i>
  </span>
<span class="btn__text-container">Open issue</span>
</a>
</li>
      
  </ul>
</div>






<div class="dropdown dropdown-download-buttons">
  <button class="btn dropdown-toggle" type="button" data-bs-toggle="dropdown" aria-expanded="false" aria-label="Download this page">
    <i class="fas fa-download"></i>
  </button>
  <ul class="dropdown-menu">
      
      
      
      <li><a href="../../_sources/notebooks/class_08/class_08_communities1.ipynb" target="_blank"
   class="btn btn-sm btn-download-source-button dropdown-item"
   title="Download source file"
   data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-file"></i>
  </span>
<span class="btn__text-container">.ipynb</span>
</a>
</li>
      
      
      
      
      <li>
<button onclick="window.print()"
  class="btn btn-sm btn-download-pdf-button dropdown-item"
  title="Print to PDF"
  data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-file-pdf"></i>
  </span>
<span class="btn__text-container">.pdf</span>
</button>
</li>
      
  </ul>
</div>




<button onclick="toggleFullScreen()"
  class="btn btn-sm btn-fullscreen-button"
  title="Fullscreen mode"
  data-bs-placement="bottom" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-expand"></i>
  </span>

</button>



<script>
document.write(`
  <button class="btn btn-sm nav-link pst-navbar-icon theme-switch-button" title="light/dark" aria-label="light/dark" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <i class="theme-switch fa-solid fa-sun fa-lg" data-mode="light"></i>
    <i class="theme-switch fa-solid fa-moon fa-lg" data-mode="dark"></i>
    <i class="theme-switch fa-solid fa-circle-half-stroke fa-lg" data-mode="auto"></i>
  </button>
`);
</script>


<script>
document.write(`
  <button class="btn btn-sm pst-navbar-icon search-button search-button__button" title="Search" aria-label="Search" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <i class="fa-solid fa-magnifying-glass fa-lg"></i>
  </button>
`);
</script>
<button class="sidebar-toggle secondary-toggle btn btn-sm" title="Toggle secondary sidebar" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <span class="fa-solid fa-list"></span>
</button>
</div></div>
      
    </div>
  
</div>
</div>
              
              

<div id="jb-print-docs-body" class="onlyprint">
    <h1>Class 08: Clustering & Community Detection 1 — Traditional</h1>
    <!-- Table of contents -->
    <div id="print-main-content">
        <div id="jb-print-toc">
            
            <div>
                <h2> Contents </h2>
            </div>
            <nav aria-label="Page">
                <ul class="visible nav section-nav flex-column">
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#community-detection-in-networks">Community Detection in Networks</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#what-is-a-community">What is a Community?</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#mathematically">Mathematically:</a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#more-formal-definitions-of-communities">More Formal Definitions of Communities</a><ul class="nav section-nav flex-column">
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#a-clique">a. Clique:</a></li>
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#b-dense-subgraph">b. Dense Subgraph:</a></li>
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#c-conductance">c. Conductance:</a></li>
</ul>
</li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#applications-of-community-detection">Applications of Community Detection</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#types-of-communities">Types of Communities</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#modularity">Modularity</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#popular-community-detection-algorithms">Popular Community Detection Algorithms</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#girvan-newman-algorithm">1. <strong>Girvan-Newman Algorithm</strong>:</a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#louvain-method">2. <strong>Louvain Method</strong>:</a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#infomap-algorithm">3. <strong>Infomap Algorithm</strong>:</a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#spectral-clustering">4. <strong>Spectral Clustering</strong>:</a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#and-many-many-many-more">And many… many… many more…</a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#challenges-in-community-detection">Challenges in Community Detection</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#resolution-limit">Resolution Limit:</a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#overlapping-communities">Overlapping Communities:</a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dynamic-and-evolving-communities">Dynamic and Evolving Communities:</a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#computational-complexity">Computational Complexity:</a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#examples-of-advanced-topics-in-community-detection">Examples of Advanced Topics in Community Detection</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#stochastic-block-models-sbm">Stochastic Block Models (SBM):</a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#label-propagation">Label Propagation:</a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#multi-layer-and-multiplex-networks">Multi-layer and Multiplex Networks:</a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#the-original-karate-club-viz">The Original Karate Club Viz</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#coding-modularity">Coding Modularity</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#method-girvan-newman">Method: Girvan Newman</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id1">Challenges in Community Detection</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#modularity-landscape">Modularity Landscape</a></li>
</ul>
</li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#method-louvain-algorithm">Method: Louvain Algorithm</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#community-detection-package-s">Community detection package(s)</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#other-common-algorithms">Other common algorithms</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#spectral-optimization">1. Spectral Optimization</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#infomap">2. Infomap</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#your-turn">3. Your turn!</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#punchline-these-methods-all-have-a-common-failing">Punchline: These methods all have a common failing</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#next-time">Next time…</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#references-and-further-resources">References and further resources:</a></li>
</ul>
            </nav>
        </div>
    </div>
</div>

              
                
<div id="searchbox"></div>
                <article class="bd-article">
                  
  <section id="class-08-clustering-community-detection-1-traditional">
<h1>Class 08: Clustering &amp; Community Detection 1 — Traditional<a class="headerlink" href="#class-08-clustering-community-detection-1-traditional" title="Link to this heading">#</a></h1>
<p>Goal of today’s class:</p>
<ol class="arabic simple">
<li><p>Define what network communities are</p></li>
<li><p>Explore and define the <em>modularity</em> measure</p></li>
<li><p>Code some early algorithms for community detection</p></li>
</ol>
<p><em>Acknowledgement: Some of the material in this lesson is based on a previous course offered by Matteo Chinazzi and Qian Zhang.</em></p>
<hr class="docutils" />
<ol class="arabic simple">
<li><p>Come in. Sit down. Open Teams.</p></li>
<li><p>Find your notebook in your /Class_08/ folder.</p></li>
</ol>
<hr class="docutils" />
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span><span class="w"> </span><span class="nn">networkx</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">nx</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">matplotlib.pyplot</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">plt</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">matplotlib</span><span class="w"> </span><span class="kn">import</span> <span class="n">rc</span>
<span class="n">rc</span><span class="p">(</span><span class="s1">&#39;axes&#39;</span><span class="p">,</span> <span class="n">fc</span><span class="o">=</span><span class="s1">&#39;w&#39;</span><span class="p">)</span>
<span class="n">rc</span><span class="p">(</span><span class="s1">&#39;figure&#39;</span><span class="p">,</span> <span class="n">fc</span><span class="o">=</span><span class="s1">&#39;w&#39;</span><span class="p">)</span>
<span class="n">rc</span><span class="p">(</span><span class="s1">&#39;savefig&#39;</span><span class="p">,</span> <span class="n">fc</span><span class="o">=</span><span class="s1">&#39;w&#39;</span><span class="p">)</span>
<span class="n">rc</span><span class="p">(</span><span class="s1">&#39;axes&#39;</span><span class="p">,</span> <span class="n">axisbelow</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<section id="community-detection-in-networks">
<h2>Community Detection in Networks<a class="headerlink" href="#community-detection-in-networks" title="Link to this heading">#</a></h2>
<p>Community detection is one of the most important tasks in network science and graph theory, focusing on identifying groups of nodes that are more densely connected to each other than to the rest of the network. These groups, often referred to as <strong>communities</strong>, <strong>modules</strong>, <strong>clusters</strong>, <strong>blocks</strong> are essential for understanding the structure and function of complex systems represented as graphs, such as social networks, biological systems, and information networks.</p>
<hr class="docutils" />
<section id="what-is-a-community">
<h3>What is a Community?<a class="headerlink" href="#what-is-a-community" title="Link to this heading">#</a></h3>
<p>A <strong>community</strong> in a network can be intuitively understood as a subset of nodes where connections (edges) between members of the community are more frequent or stronger than connections to the rest of the network. In mathematical terms, a graph $ G = (V, E) $, where $ V $ represents the set of nodes and $ E $ represents the set of edges, can be partitioned into communities $ C_1, C_2, \dots, C_k $ such that:</p>
<p>$$
\sum_{i=1}^{k} \left( \text{Intra-community edges in } C_i \right) \gg \text{Inter-community edges between } C_i \text{ and other communities}.
$$</p>
<p>This means that each community $ C_i $ has a higher density of internal connections compared to its connections to other communities in the network.</p>
<p>A <strong>community</strong> is generally defined as a subset of nodes that are densely connected internally, but sparsely connected to nodes outside the community. In other words, members of a community have many intra-community edges but relatively few inter-community edges.</p>
<section id="mathematically">
<h4>Mathematically:<a class="headerlink" href="#mathematically" title="Link to this heading">#</a></h4>
<p>For a given community $ C \subseteq V $, the internal density of edges is much higher than the external density:</p>
<p>$$
\frac{\text{Intra-community edges in } C}{|C|}
$$
should be maximized, while the number of <strong>inter-community edges</strong> should be minimized.</p>
<p>The goal of <strong>community detection</strong> is to partition the nodes of the network into communities $ C_1, C_2, \dots, C_k $ such that the intra-community connections are maximized and inter-community connections are minimized. Formally, the network is partitioned into $ k $ subsets:</p>
<p>$$
V = \bigcup_{i=1}^{k} C_i \quad \text{with} \quad C_i \cap C_j = \emptyset \quad \forall i \neq j.
$$</p>
<p>In practice, community detection helps in revealing the underlying structure of the network and offers insights into the network’s functional modules, social groups, or thematic clusters.</p>
</section>
<hr class="docutils" />
<section id="more-formal-definitions-of-communities">
<h4>More Formal Definitions of Communities<a class="headerlink" href="#more-formal-definitions-of-communities" title="Link to this heading">#</a></h4>
<p>Communities can be defined in several ways, each based on different structural properties:</p>
<section id="a-clique">
<h5>a. Clique:<a class="headerlink" href="#a-clique" title="Link to this heading">#</a></h5>
<p>A <strong>clique</strong> is the most restrictive form of a community, where every node is connected to every other node in the community. In a graph, a clique of size $ k $ is a subgraph $ K_k $ where every pair of nodes has an edge:</p>
<p>$$ \forall v_i, v_j \in C : (v_i, v_j) \in E. $$</p>
<p>However, real-world networks rarely exhibit perfect cliques.</p>
</section>
<section id="b-dense-subgraph">
<h5>b. Dense Subgraph:<a class="headerlink" href="#b-dense-subgraph" title="Link to this heading">#</a></h5>
<p>A less restrictive notion than cliques, a dense subgraph satisfies a high ratio of existing edges to potential edges. The density $ d(C) $ of a community $ C $ is defined as:</p>
<p>$$ d(C) = \frac{|E_C|}{|C|(|C| - 1) / 2}, $$</p>
<p>where $ E_C $ represents the number of edges within community $ C $. A high density indicates a tightly-knit group.</p>
</section>
<section id="c-conductance">
<h5>c. Conductance:<a class="headerlink" href="#c-conductance" title="Link to this heading">#</a></h5>
<p>The <strong>conductance</strong> of a community $ C $ measures the fraction of total edge volume that points outside the community:</p>
<p>$$ \Phi(C) = \frac{\sum_{i \in C, j \notin C} A_{ij}}{\min(\text{vol}(C), \text{vol}(V \setminus C))}, $$</p>
<p>where $ \text{vol}(C) $ is the sum of degrees of nodes in $ C $. Low conductance implies strong community structure.</p>
</section>
</section>
</section>
<hr class="docutils" />
<section id="applications-of-community-detection">
<h3>Applications of Community Detection<a class="headerlink" href="#applications-of-community-detection" title="Link to this heading">#</a></h3>
<p>Community detection has wide-ranging applications across various disciplines:</p>
<ul class="simple">
<li><p><strong>Social Networks</strong>: Communities often correspond to real-world groups such as families, friends, or professional associations.</p></li>
<li><p><strong>Biological Networks</strong>: In protein-protein interaction networks, communities may represent functional modules of proteins working together.</p></li>
<li><p><strong>Information Networks</strong>: In citation networks, communities may represent topics or research areas.</p></li>
<li><p><strong>Infrastructure</strong>: In power grids or transportation networks, communities can indicate regions or hubs that are densely interconnected.</p></li>
</ul>
<p>By identifying communities, one can gain insights into the <strong>organization</strong>, <strong>function</strong>, and <strong>dynamics</strong> of complex systems.</p>
</section>
<hr class="docutils" />
<section id="types-of-communities">
<h3>Types of Communities<a class="headerlink" href="#types-of-communities" title="Link to this heading">#</a></h3>
<p>Communities can be defined in different ways, depending on the nature of the network and the type of analysis required:</p>
<ul class="simple">
<li><p><strong>Disjoint Communities</strong>: Each node belongs to exactly one community. Most algorithms, such as <strong>Louvain</strong> or <strong>Girvan-Newman</strong>, find disjoint partitions.</p></li>
<li><p><strong>Overlapping Communities</strong>: Nodes can belong to more than one community, which is useful for networks where entities have multiple affiliations (e.g., people belonging to different social groups).</p></li>
<li><p><strong>Hierarchical Communities</strong>: Communities can be nested, forming a hierarchy where smaller, denser communities are part of larger ones. This is common in many real-world networks like biological systems and organizational structures.</p></li>
</ul>
<hr class="docutils" />
<p>Community detection is a critical tool for uncovering the hidden structure in complex networks, offering insights into how systems are organized. While many algorithms have been proposed, choosing the right one depends on the nature of the network, the expected community structure, and the scalability required for the task. Ongoing research continues to improve methods for detecting overlapping, hierarchical, and dynamic communities, making this an exciting area of study in network science.</p>
<p>Community detection continues to be a dynamic field of research with applications spanning biology, sociology, economics, and computer science. Despite the wealth of methods available, no single algorithm works best for all types of networks, and researchers must often tailor their approaches based on the specific structure and dynamics of the network at hand.</p>
<p>As networks become larger and more complex, the demand for scalable, accurate, and interpretable community detection methods will only grow. Future research will likely focus on multi-layer, overlapping, and dynamic community detection, along with developing new performance measures beyond modularity.</p>
</section>
</section>
<hr class="docutils" />
<section id="modularity">
<h2>Modularity<a class="headerlink" href="#modularity" title="Link to this heading">#</a></h2>
<p>One of the most widely used metrics for evaluating the quality of a community structure is <strong>modularity</strong>, proposed by Newman and Girvan (2004). Modularity purports to measure the difference between the actual number of intra-community edges and the expected number of such edges in a random graph with the same degree distribution. The modularity, $Q$, of a given partition $C$ of our adjacency matrix $A$ is:</p>
<p>$$Q (A,C) = \frac{1}{2M} \sum_{i,j} \left( A_{ij} - \frac{k_i k_j}{2M} \right) \delta (C_i,C_j) $$</p>
<p>Where:</p>
<ul class="simple">
<li><p>$ A_{ij} $ is the element of the adjacency matrix (1 if there is an edge between nodes $i$ and $j$, 0 otherwise).</p></li>
<li><p>$ k_i $ and $ k_j $ are the degrees of nodes $i$ and $j$, respectively.</p></li>
<li><p>$ M $ is the total number of edges in the network.</p></li>
<li><p>$ \delta(C_i, C_j) $ is a Kronecker delta, equal to 1 if nodes $i$ and $j$ are in the same community, and 0 otherwise.</p></li>
</ul>
<p>Modularity values range from $-1$ to $1$, with higher values indicating stronger community structure. According to some in the early literature of modularity, values of $ Q \approx 0.3 $ or higher can signifie a significant division into communities.*</p>
<p>* <strong>Note: Today, there are strong and damning critiques of modularity as a measure. We are introducing it here as a historical exercise and as a way to motivate next class’s theme: <em>inferential approaches to community detection</em>.</strong></p>
<hr class="docutils" />
<section id="popular-community-detection-algorithms">
<h3>Popular Community Detection Algorithms<a class="headerlink" href="#popular-community-detection-algorithms" title="Link to this heading">#</a></h3>
<p>Several algorithms have been developed for detecting communities in networks, each with different approaches and optimizations:</p>
<section id="girvan-newman-algorithm">
<h4>1. <strong>Girvan-Newman Algorithm</strong>:<a class="headerlink" href="#girvan-newman-algorithm" title="Link to this heading">#</a></h4>
<p>The <strong>Girvan-Newman</strong> algorithm is a hierarchical method based on <strong>betweenness centrality</strong> of edges. The idea is to iteratively remove edges with the highest betweenness centrality, causing the network to break into disconnected components.</p>
<ul class="simple">
<li><p><strong>Betweenness Centrality</strong>: For an edge $ e $, the betweenness centrality is the number of shortest paths between all pairs of nodes that pass through $ e $.</p></li>
</ul>
<p>The process continues until the network splits into predefined or data-driven numbers of communities.</p>
<p><strong>Time complexity</strong>: $ O(n^3) $, making it impractical for large networks.</p>
</section>
<section id="louvain-method">
<h4>2. <strong>Louvain Method</strong>:<a class="headerlink" href="#louvain-method" title="Link to this heading">#</a></h4>
<p>The <strong>Louvain method</strong> is a popular greedy optimization technique for maximizing modularity. It works in two phases:</p>
<ol class="arabic simple">
<li><p><strong>Local Modularity Maximization</strong>: Each node is initially assigned to its own community. Nodes are then reassigned to neighboring communities if doing so increases modularity.</p></li>
<li><p><strong>Community Aggregation</strong>: Once no more reassignments can improve modularity, the network is compressed by treating each community as a “super-node.”</p></li>
</ol>
<p>This process is repeated until no further improvement in modularity is possible.</p>
<p><strong>Time complexity</strong>: $ O(n \log n) $, making it scalable for large networks.</p>
</section>
<section id="infomap-algorithm">
<h4>3. <strong>Infomap Algorithm</strong>:<a class="headerlink" href="#infomap-algorithm" title="Link to this heading">#</a></h4>
<p>The <strong>Infomap</strong> algorithm approaches community detection from an information-theoretic perspective. It models random walks on the graph and optimizes the coding length needed to describe these walks.</p>
<ul class="simple">
<li><p>The idea is to partition the network such that a random walker spends more time within communities than between them, leading to a more concise encoding of its movement.</p></li>
</ul>
<p>Infomap is known for detecting hierarchical and overlapping communities.</p>
<p><strong>Time complexity</strong>: $ O(m \log n) $.</p>
</section>
<section id="spectral-clustering">
<h4>4. <strong>Spectral Clustering</strong>:<a class="headerlink" href="#spectral-clustering" title="Link to this heading">#</a></h4>
<p><strong>Spectral clustering</strong> relies on the eigenvalues and eigenvectors of the <strong>graph Laplacian</strong> matrix. The <strong>Laplacian matrix</strong> $ L $ is defined as:</p>
<p>$$ L = D - A, $$</p>
<p>where $ D $ is the degree matrix and $ A $ is the adjacency matrix. Spectral clustering leverages the second-smallest eigenvalue (the <strong>Fiedler value</strong>) and the corresponding eigenvector to find the best partition of nodes into communities.</p>
<p><strong>Time complexity</strong>: $ O(n^3) $, as eigenvalue decomposition can be computationally intensive.</p>
</section>
<hr class="docutils" />
<section id="and-many-many-many-more">
<h4>And many… many… many more…<a class="headerlink" href="#and-many-many-many-more" title="Link to this heading">#</a></h4>
<p><img alt="" src="../../_images/karate_fig.png" /></p>
</section>
</section>
<hr class="docutils" />
<section id="challenges-in-community-detection">
<h3>Challenges in Community Detection<a class="headerlink" href="#challenges-in-community-detection" title="Link to this heading">#</a></h3>
<p>Although significant progress has been made in developing community detection algorithms, several challenges remain:</p>
<section id="resolution-limit">
<h4>Resolution Limit:<a class="headerlink" href="#resolution-limit" title="Link to this heading">#</a></h4>
<p>Modularity-based methods, like Louvain, suffer from a <strong>resolution limit</strong>, meaning that they may fail to detect small but dense communities. This occurs because modularity optimization tends to merge small communities into larger ones when it improves the overall modularity score.</p>
</section>
<section id="overlapping-communities">
<h4>Overlapping Communities:<a class="headerlink" href="#overlapping-communities" title="Link to this heading">#</a></h4>
<p>In many real-world networks, communities often overlap, i.e., nodes belong to multiple communities (e.g., in social networks, a person can belong to multiple social groups). Most traditional algorithms are designed to find disjoint communities, making it difficult to handle overlapping structures.</p>
</section>
<section id="dynamic-and-evolving-communities">
<h4>Dynamic and Evolving Communities:<a class="headerlink" href="#dynamic-and-evolving-communities" title="Link to this heading">#</a></h4>
<p>Real-world networks are often dynamic, meaning nodes and edges can appear and disappear over time. Detecting communities in evolving networks requires more sophisticated methods that take temporal dynamics into account.</p>
</section>
<section id="computational-complexity">
<h4>Computational Complexity:<a class="headerlink" href="#computational-complexity" title="Link to this heading">#</a></h4>
<p>For large-scale networks (millions of nodes and edges), community detection becomes computationally expensive. Scalability and performance optimizations are essential for practical applications in big data networks.</p>
</section>
</section>
<hr class="docutils" />
<section id="examples-of-advanced-topics-in-community-detection">
<h3>Examples of Advanced Topics in Community Detection<a class="headerlink" href="#examples-of-advanced-topics-in-community-detection" title="Link to this heading">#</a></h3>
<section id="stochastic-block-models-sbm">
<h4>Stochastic Block Models (SBM):<a class="headerlink" href="#stochastic-block-models-sbm" title="Link to this heading">#</a></h4>
<p>Stochastic block models are probabilistic models that generate networks with a predefined community structure. In an SBM, edges between nodes are created based on probabilities determined by the community assignments of the nodes. <strong>This will be the topic of next class’s discussion.</strong></p>
</section>
<section id="label-propagation">
<h4>Label Propagation:<a class="headerlink" href="#label-propagation" title="Link to this heading">#</a></h4>
<p>Label Propagation is a simple and efficient algorithm where each node adopts the most frequent community label among its neighbors. This process is repeated until no node changes its label. The method is fast but may lead to unstable partitions.</p>
</section>
<section id="multi-layer-and-multiplex-networks">
<h4>Multi-layer and Multiplex Networks:<a class="headerlink" href="#multi-layer-and-multiplex-networks" title="Link to this heading">#</a></h4>
<p>In multi-layer or multiplex networks, nodes can belong to multiple layers (e.g., different types of interactions in social media), and the challenge is to detect communities across layers. Algorithms that handle multi-layer networks are still being actively researched.</p>
<hr class="docutils" />
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># we actually have some notion of &quot;ground truth&quot; in the karate club...</span>
<span class="n">K</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">karate_club_graph</span><span class="p">()</span>
<span class="n">pos</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">spring_layout</span><span class="p">(</span><span class="n">K</span><span class="p">)</span>

<span class="n">club_color</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s1">&#39;Mr. Hi&#39;</span><span class="p">:</span> <span class="s1">&#39;teal&#39;</span><span class="p">,</span>
    <span class="s1">&#39;Officer&#39;</span><span class="p">:</span> <span class="s1">&#39;limegreen&#39;</span><span class="p">,</span>
<span class="p">}</span>
<span class="n">node_colors</span> <span class="o">=</span> <span class="p">[</span><span class="n">club_color</span><span class="p">[</span><span class="n">K</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">n</span><span class="p">][</span><span class="s1">&#39;club&#39;</span><span class="p">]]</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">K</span><span class="o">.</span><span class="n">nodes</span><span class="p">]</span>

<span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">7</span><span class="p">,</span><span class="mi">5</span><span class="p">),</span><span class="n">dpi</span><span class="o">=</span><span class="mi">100</span><span class="p">)</span>
<span class="n">nx</span><span class="o">.</span><span class="n">draw</span><span class="p">(</span><span class="n">K</span><span class="p">,</span> <span class="n">pos</span><span class="p">,</span> <span class="n">node_color</span><span class="o">=</span><span class="n">node_colors</span><span class="p">,</span> <span class="n">with_labels</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span><span class="n">ax</span><span class="o">=</span><span class="n">ax</span><span class="p">)</span>

<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="../../_images/e4215f4484c0c492e17732122ef670c689f48f360ed779390fae23e9c48950a8.png" src="../../_images/e4215f4484c0c492e17732122ef670c689f48f360ed779390fae23e9c48950a8.png" />
</div>
</div>
</section>
</section>
<hr class="docutils" />
<section id="the-original-karate-club-viz">
<h3>The Original Karate Club Viz<a class="headerlink" href="#the-original-karate-club-viz" title="Link to this heading">#</a></h3>
<p><img alt="" src="../../_images/karate_og.png" /></p>
</section>
</section>
<section id="coding-modularity">
<h2>Coding Modularity<a class="headerlink" href="#coding-modularity" title="Link to this heading">#</a></h2>
<p>Recall from above, the definition of the <em>modularity</em> of a partition, $C$ of a graph $A$:</p>
<p>$$Q (A,C) = \frac{1}{2M} \sum_{i,j} \left( A_{ij} - \frac{k_i k_j}{2M} \right) \delta (C_i,C_j) $$</p>
<p>What are the key steps we’ll need to do in order to implement this?</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Your turn! </span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span><span class="w"> </span><span class="nf">calculate_modularity</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">partition</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Calculates the modularity score for a given partition of the graph, whether the graph is weighted or unweighted.</span>
<span class="sd">    </span>
<span class="sd">    Modularity is a measure of the strength of division of a network into communities. It compares the actual </span>
<span class="sd">    density of edges within communities to the expected density if edges were distributed randomly. For weighted </span>
<span class="sd">    graphs, the weight of the edges is taken into account.</span>

<span class="sd">    The modularity Q is calculated as:</span>
<span class="sd">    </span>
<span class="sd">    Q = (1 / 2m) * sum((A_ij - (k_i * k_j) / (2m)) * delta(c_i, c_j))</span>

<span class="sd">    where:</span>
<span class="sd">    - A_ij is the weight of the edge between nodes i and j (1 if unweighted).</span>
<span class="sd">    - k_i is the degree of node i (or the weighted degree for weighted graphs).</span>
<span class="sd">    - m is the total number of edges in the graph, or the total weight of the edges if the graph is weighted.</span>
<span class="sd">    - delta(c_i, c_j) is 1 if nodes i and j belong to the same community, and 0 otherwise.</span>

<span class="sd">    Parameters:</span>
<span class="sd">    -----------</span>
<span class="sd">    G : networkx.Graph</span>
<span class="sd">        The input graph, which can be undirected and either weighted or unweighted. The graph&#39;s nodes represent the </span>
<span class="sd">        entities, and its edges represent connections between them.</span>
<span class="sd">    </span>
<span class="sd">    partition : list of sets</span>
<span class="sd">        A list of sets where each set represents a community. Each set contains the nodes belonging to that community. </span>
<span class="sd">        For example, [{0, 1, 2}, {3, 4}] represents two communities, one with nodes 0, 1, and 2, and another with nodes </span>
<span class="sd">        3 and 4.</span>
<span class="sd">    </span>
<span class="sd">    Returns:</span>
<span class="sd">    --------</span>
<span class="sd">    modularity_score : float</span>
<span class="sd">        The modularity score for the given partition of the graph. A higher score indicates stronger community structure, </span>
<span class="sd">        and a lower (or negative) score suggests weak or no community structure.</span>

<span class="sd">    Notes:</span>
<span class="sd">    ------</span>
<span class="sd">    - If the graph has weights, they will be used in the modularity calculation. If no weights are present, the function </span>
<span class="sd">      assumes each edge has a weight of 1 (i.e., unweighted).</span>
<span class="sd">    </span>
<span class="sd">    - The function assumes that all nodes in the graph are assigned to exactly one community. If any node is missing </span>
<span class="sd">      from the community list, it is treated as not belonging to any community, and the results may not be accurate.</span>
<span class="sd">    </span>
<span class="sd">    - If the graph has no edges, the modularity is undefined, and this function will return 0 because the total number </span>
<span class="sd">      of edges (2m) would be zero.</span>
<span class="sd">    </span>
<span class="sd">    Example:</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; import networkx as nx</span>
<span class="sd">    &gt;&gt;&gt; G = nx.karate_club_graph()</span>
<span class="sd">    &gt;&gt;&gt; communities = [{0, 1, 2, 3, 4}, {5, 6, 7, 8, 9, 10}]</span>
<span class="sd">    &gt;&gt;&gt; modularity_score = calculate_modularity(G, communities)</span>
<span class="sd">    &gt;&gt;&gt; print(&quot;Modularity:&quot;, modularity_score)</span>
<span class="sd">    </span>
<span class="sd">    References:</span>
<span class="sd">    -----------</span>
<span class="sd">    Newman, M. E. J., &amp; Girvan, M. (2004). Finding and evaluating community structure </span>
<span class="sd">    in networks. Physical Review E, 69(2), 026113.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    

    <span class="k">pass</span>
</pre></div>
</div>
</div>
</div>
<p><strong>Don’t look below!</strong></p>
<hr class="docutils" />
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span><span class="w"> </span><span class="nf">calculate_modularity</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">partition</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Calculates the modularity score for a given partition of the graph, whether the graph is weighted or unweighted.</span>
<span class="sd">    </span>
<span class="sd">    Modularity is a measure of the strength of division of a network into communities. It compares the actual </span>
<span class="sd">    density of edges within communities to the expected density if edges were distributed randomly. For weighted </span>
<span class="sd">    graphs, the weight of the edges is taken into account.</span>

<span class="sd">    The modularity Q is calculated as:</span>
<span class="sd">    </span>
<span class="sd">    Q = (1 / 2m) * sum((A_ij - (k_i * k_j) / (2m)) * delta(c_i, c_j))</span>

<span class="sd">    where:</span>
<span class="sd">    - A_ij is the weight of the edge between nodes i and j (1 if unweighted).</span>
<span class="sd">    - k_i is the degree of node i (or the weighted degree for weighted graphs).</span>
<span class="sd">    - m is the total number of edges in the graph, or the total weight of the edges if the graph is weighted.</span>
<span class="sd">    - delta(c_i, c_j) is 1 if nodes i and j belong to the same community, and 0 otherwise.</span>

<span class="sd">    Parameters:</span>
<span class="sd">    -----------</span>
<span class="sd">    G : networkx.Graph</span>
<span class="sd">        The input graph, which can be undirected and either weighted or unweighted. The graph&#39;s nodes represent the </span>
<span class="sd">        entities, and its edges represent connections between them.</span>
<span class="sd">    </span>
<span class="sd">    partition : list of sets</span>
<span class="sd">        A list of sets where each set represents a community. Each set contains the nodes belonging to that community. </span>
<span class="sd">        For example, [{0, 1, 2}, {3, 4}] represents two communities, one with nodes 0, 1, and 2, and another with nodes </span>
<span class="sd">        3 and 4.</span>
<span class="sd">    </span>
<span class="sd">    Returns:</span>
<span class="sd">    --------</span>
<span class="sd">    modularity_score : float</span>
<span class="sd">        The modularity score for the given partition of the graph. A higher score indicates stronger community structure, </span>
<span class="sd">        and a lower (or negative) score suggests weak or no community structure.</span>

<span class="sd">    Notes:</span>
<span class="sd">    ------</span>
<span class="sd">    - If the graph has weights, they will be used in the modularity calculation. If no weights are present, the function </span>
<span class="sd">      assumes each edge has a weight of 1 (i.e., unweighted).</span>
<span class="sd">    </span>
<span class="sd">    - The function assumes that all nodes in the graph are assigned to exactly one community. If any node is missing </span>
<span class="sd">      from the community list, it is treated as not belonging to any community, and the results may not be accurate.</span>
<span class="sd">    </span>
<span class="sd">    - If the graph has no edges, the modularity is undefined, and this function will return 0 because the total number </span>
<span class="sd">      of edges (2m) would be zero.</span>
<span class="sd">    </span>
<span class="sd">    Example:</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; import networkx as nx</span>
<span class="sd">    &gt;&gt;&gt; G = nx.karate_club_graph()</span>
<span class="sd">    &gt;&gt;&gt; communities = [{0, 1, 2, 3, 4}, {5, 6, 7, 8, 9, 10}]</span>
<span class="sd">    &gt;&gt;&gt; modularity_score = calculate_modularity(G, communities)</span>
<span class="sd">    &gt;&gt;&gt; print(&quot;Modularity:&quot;, modularity_score)</span>
<span class="sd">    </span>
<span class="sd">    References:</span>
<span class="sd">    -----------</span>
<span class="sd">    Newman, M. E. J., &amp; Girvan, M. (2004). Finding and evaluating community structure </span>
<span class="sd">    in networks. Physical Review E, 69(2), 026113.</span>
<span class="sd">    &quot;&quot;&quot;</span>
  
    <span class="k">def</span><span class="w"> </span><span class="nf">remap_partition</span><span class="p">(</span><span class="n">partition</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Converts and remaps a partition to a list-of-lists structure suitable for modularity calculations.</span>

<span class="sd">        This function remaps the input partition (whether it&#39;s in dictionary form or a flat list of community labels) </span>
<span class="sd">        to a list-of-lists format, where each list represents a community and contains the nodes in that community. </span>
<span class="sd">        The function also ensures that community labels are contiguous integers starting from 0, which is typically </span>
<span class="sd">        required for modularity-based algorithms.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># if partition is a dictionary where the keys are nodes and values communities</span>
        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">partition</span><span class="p">)</span><span class="o">==</span><span class="nb">dict</span><span class="p">:</span>
            <span class="n">unique_comms</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">partition</span><span class="o">.</span><span class="n">values</span><span class="p">()))</span>
            <span class="n">comm_mapping</span> <span class="o">=</span> <span class="p">{</span><span class="n">i</span><span class="p">:</span><span class="n">ix</span> <span class="k">for</span> <span class="n">ix</span><span class="p">,</span><span class="n">i</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">unique_comms</span><span class="p">)}</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">j</span> <span class="ow">in</span> <span class="n">partition</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="n">partition</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">comm_mapping</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>

            <span class="n">unique_comms</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">partition</span><span class="o">.</span><span class="n">values</span><span class="p">()))</span>
            <span class="n">communities</span> <span class="o">=</span> <span class="p">[[]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">unique_comms</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">j</span> <span class="ow">in</span> <span class="n">partition</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="n">communities</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
                
            <span class="k">return</span> <span class="n">communities</span>

        <span class="c1"># if partition is a list of community assignments</span>
        <span class="k">elif</span> <span class="nb">type</span><span class="p">(</span><span class="n">partition</span><span class="p">)</span><span class="o">==</span><span class="nb">list</span> <span class="ow">and</span>\
                <span class="ow">not</span> <span class="nb">any</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">el</span><span class="p">,</span> <span class="nb">list</span><span class="p">)</span> <span class="k">for</span> <span class="n">el</span> <span class="ow">in</span> <span class="n">partition</span><span class="p">):</span>
            <span class="n">unique_comms</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">partition</span><span class="p">)</span>
            <span class="n">comm_mapping</span> <span class="o">=</span> <span class="p">{</span><span class="n">i</span><span class="p">:</span><span class="n">ix</span> <span class="k">for</span> <span class="n">ix</span><span class="p">,</span><span class="n">i</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">unique_comms</span><span class="p">)}</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">j</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">partition</span><span class="p">):</span>
                <span class="n">partition</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">comm_mapping</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>

            <span class="n">unique_comms</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">partition</span><span class="p">)</span>
            <span class="n">communities</span> <span class="o">=</span> <span class="p">[[]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">partition</span><span class="p">)]</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">j</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">partition</span><span class="p">):</span>
                <span class="n">communities</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>

            <span class="k">return</span> <span class="n">communities</span>

        <span class="c1"># otherwise assume input is a properly-formatted list of lists</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">communities</span> <span class="o">=</span> <span class="n">partition</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="k">return</span> <span class="n">communities</span>


    <span class="c1"># We now should have a list-of-lists structure for communities</span>
    <span class="n">communities</span> <span class="o">=</span> <span class="n">remap_partition</span><span class="p">(</span><span class="n">partition</span><span class="p">)</span>
    
    <span class="c1"># Total weight of edges in the graph (or number of edges if unweighted)</span>
    <span class="k">if</span> <span class="n">nx</span><span class="o">.</span><span class="n">is_weighted</span><span class="p">(</span><span class="n">G</span><span class="p">):</span>
        <span class="n">m</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="n">weight</span><span class="o">=</span><span class="s1">&#39;weight&#39;</span><span class="p">)</span>
        <span class="n">degree</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">G</span><span class="o">.</span><span class="n">degree</span><span class="p">(</span><span class="n">weight</span><span class="o">=</span><span class="s1">&#39;weight&#39;</span><span class="p">))</span>  <span class="c1"># Weighted degree for each node</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">m</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">number_of_edges</span><span class="p">()</span>  <span class="c1"># Number of edges in the graph</span>
        <span class="n">degree</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">G</span><span class="o">.</span><span class="n">degree</span><span class="p">())</span>  <span class="c1"># Degree for each node (unweighted)</span>

    <span class="c1"># Modularity score</span>
    <span class="n">modularity_score</span> <span class="o">=</span> <span class="mf">0.0</span>
    
    <span class="c1"># Loop over all pairs of nodes i, j within the same community</span>
    <span class="k">for</span> <span class="n">community</span> <span class="ow">in</span> <span class="n">communities</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">community</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">community</span><span class="p">:</span>
                <span class="c1"># Get the weight of the edge between i and j, or assume weight 1 if unweighted</span>
                <span class="k">if</span> <span class="n">G</span><span class="o">.</span><span class="n">has_edge</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">):</span>
                    <span class="n">A_ij</span> <span class="o">=</span> <span class="n">G</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;weight&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>  <span class="c1"># Use weight if available, otherwise assume 1</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">A_ij</span> <span class="o">=</span> <span class="mi">0</span>  <span class="c1"># No edge between i and j</span>

                <span class="c1"># Expected number of edges (or weighted edges) between i and j in a random graph</span>
                <span class="n">expected_edges</span> <span class="o">=</span> <span class="p">(</span><span class="n">degree</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="n">degree</span><span class="p">[</span><span class="n">j</span><span class="p">])</span> <span class="o">/</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">m</span><span class="p">)</span>

                <span class="c1"># Contribution to modularity</span>
                <span class="n">modularity_score</span> <span class="o">+=</span> <span class="p">(</span><span class="n">A_ij</span> <span class="o">-</span> <span class="n">expected_edges</span><span class="p">)</span>

    <span class="c1"># Normalize by the total number of edges (or total edge weight) 2m</span>
    <span class="n">modularity_score</span> <span class="o">/=</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">m</span><span class="p">)</span>


    <span class="k">return</span> <span class="n">modularity_score</span>
</pre></div>
</div>
</div>
</div>
</section>
<hr class="docutils" />
<section id="method-girvan-newman">
<h2>Method: Girvan Newman<a class="headerlink" href="#method-girvan-newman" title="Link to this heading">#</a></h2>
<p>The Girvan-Newman method [1] is a <em>divisive</em> algorithm that iteratively removes the edges connecting the different clusters until the optimal partition is found and the communities are fully isolated. The algorithm calculates a score for each edge (in this case, <em>edge betweenness</em>, though others could have been considered), ranks these scores, and iteratively removes them from the graph. At each iteration, the modularity of the partition of (dis)connected components is measured. We repeat this step until the graph has no edges, and the partition with the highest modularity is chosen.</p>
<p><img alt="" src="../../_images/girvan_newman.png" /></p>
<p>[1] Girvan M. &amp; Newman M.E.J. (2002). <strong>Community structure in social and biological networks</strong>. Proceedings of the National Academy of Sciences, 99, 7821–7826. https://doi.org/10.1073/pnas.122653799.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span><span class="w"> </span><span class="nn">networkx</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">nx</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">networkx.algorithms.community</span><span class="w"> </span><span class="kn">import</span> <span class="n">modularity</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">community</span>

<span class="k">def</span><span class="w"> </span><span class="nf">girvan_newman</span><span class="p">(</span><span class="n">H</span><span class="p">,</span> <span class="n">output</span><span class="o">=</span><span class="s1">&#39;dict&#39;</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Implements the Girvan-Newman algorithm for detecting communities in a graph.</span>
<span class="sd">    </span>
<span class="sd">    The Girvan-Newman method works by iteratively removing edges from the graph </span>
<span class="sd">    based on their edge betweenness centrality, which is a measure of the frequency </span>
<span class="sd">    with which edges appear on the shortest paths between pairs of nodes. As edges </span>
<span class="sd">    with high centrality values are removed, the graph breaks down into smaller </span>
<span class="sd">    connected components, each representing a community.</span>
<span class="sd">    </span>
<span class="sd">    Parameters:</span>
<span class="sd">    -----------</span>
<span class="sd">    H : networkx.Graph</span>
<span class="sd">        The input graph on which to perform community detection.</span>
<span class="sd">    </span>
<span class="sd">    output : strong, optional (default=&#39;dict&#39;)</span>
<span class="sd">        &#39;dict&#39;  - the algorithm will return a dictionary where the keys correspond to</span>
<span class="sd">                  nodes and values are the community label</span>
<span class="sd">        &#39;lists&#39; - a list of lists of length n_comms will be returned, such that the ith</span>
<span class="sd">                  element of the list contains a nodelist of nodes that are assigned to</span>
<span class="sd">                  community i</span>
<span class="sd">        &#39;list&#39;  - a list of community assignments, in the same order as G.nodes()</span>
<span class="sd">    </span>
<span class="sd">    Returns:</span>
<span class="sd">    --------</span>
<span class="sd">    dict:</span>
<span class="sd">        A dictionary or similar object where the keys are node identifiers and</span>
<span class="sd">        the values are  community labels (integers), indicating which</span>
<span class="sd">        community each node belongs to.</span>
<span class="sd">    </span>
<span class="sd">    </span>
<span class="sd">    Notes:</span>
<span class="sd">    ------</span>
<span class="sd">    - Modularity is a measure of the strength of the division of a network into </span>
<span class="sd">      communities. Higher values indicate stronger community structure.</span>
<span class="sd">    </span>
<span class="sd">    - The Girvan-Newman algorithm is computationally expensive (O(n*m^2), where n </span>
<span class="sd">      is the number of nodes and m is the number of edges), making it impractical </span>
<span class="sd">      for very large graphs.</span>
<span class="sd">    </span>
<span class="sd">    Example:</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; import networkx as nx</span>
<span class="sd">    &gt;&gt;&gt; G = nx.karate_club_graph()</span>
<span class="sd">    &gt;&gt;&gt; partition = girvan_newman(G)</span>
<span class="sd">    &gt;&gt;&gt; for node, community in partition.items():</span>
<span class="sd">    &gt;&gt;&gt;     print(f&quot;Node {node} belongs to community {community}&quot;)</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># Make a copy of the graph so we don&#39;t modify the original graph</span>
    <span class="n">G</span> <span class="o">=</span> <span class="n">H</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

    <span class="c1"># Initialize variables to track the best partition and modularity</span>
    <span class="n">best_partition</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">best_modularity</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>

    <span class="c1"># Keep removing edges until all components are disconnected</span>
    <span class="k">while</span> <span class="n">G</span><span class="o">.</span><span class="n">number_of_edges</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="c1"># Compute edge betweenness centrality for all edges</span>
        <span class="n">edge_betweenness</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">edge_betweenness_centrality</span><span class="p">(</span><span class="n">G</span><span class="p">)</span>

        <span class="c1"># Find the edge with the highest betweenness</span>
        <span class="n">max_edge</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">edge_betweenness</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="n">edge_betweenness</span><span class="o">.</span><span class="n">get</span><span class="p">)</span>

        <span class="c1"># Remove the edge with the highest betweenness</span>
        <span class="n">G</span><span class="o">.</span><span class="n">remove_edge</span><span class="p">(</span><span class="o">*</span><span class="n">max_edge</span><span class="p">)</span>

        <span class="c1"># Find connected components (each component is a community)</span>
        <span class="n">components</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">nx</span><span class="o">.</span><span class="n">connected_components</span><span class="p">(</span><span class="n">G</span><span class="p">))</span>

        <span class="c1"># Assign community labels to nodes</span>
        <span class="n">community_dict</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">component</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">components</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">component</span><span class="p">:</span>
                <span class="n">community_dict</span><span class="p">[</span><span class="n">node</span><span class="p">]</span> <span class="o">=</span> <span class="n">i</span>

        <span class="c1"># Compute modularity for the current partition on the original graph</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">current_modularity</span> <span class="o">=</span> <span class="n">modularity</span><span class="p">(</span><span class="n">H</span><span class="p">,</span> <span class="n">components</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">ZeroDivisionError</span><span class="p">:</span>
            <span class="c1"># If division by zero occurs, set modularity to 0</span>
            <span class="n">current_modularity</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="c1"># If this modularity is better than the best so far, store it</span>
        <span class="k">if</span> <span class="n">current_modularity</span> <span class="o">&gt;</span> <span class="n">best_modularity</span><span class="p">:</span>
            <span class="n">best_modularity</span> <span class="o">=</span> <span class="n">current_modularity</span>
            <span class="n">best_partition</span> <span class="o">=</span> <span class="n">community_dict</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

    <span class="n">best_partition</span> <span class="o">=</span> <span class="p">{</span><span class="n">i</span><span class="p">:</span><span class="n">best_partition</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="p">()}</span>
    <span class="c1"># Return the best partition</span>
    <span class="k">if</span> <span class="n">output</span> <span class="o">==</span> <span class="s1">&#39;dict&#39;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">best_partition</span>

    <span class="k">if</span> <span class="n">output</span> <span class="o">==</span> <span class="s1">&#39;list&#39;</span><span class="p">:</span>
        <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="n">best_partition</span><span class="o">.</span><span class="n">values</span><span class="p">())</span>
        
    <span class="k">if</span> <span class="n">output</span> <span class="o">==</span> <span class="s1">&#39;lists&#39;</span><span class="p">:</span>
        <span class="n">comm_out</span> <span class="o">=</span> <span class="p">[[]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">best_partition</span><span class="o">.</span><span class="n">values</span><span class="p">()))]</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">j</span> <span class="ow">in</span> <span class="n">best_partition</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">comm_out</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">comm_out</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Create a graph</span>
<span class="n">G</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">karate_club_graph</span><span class="p">()</span>

<span class="c1"># Run the Girvan-Newman algorithm with modularity tracking</span>
<span class="n">best_partition</span> <span class="o">=</span> <span class="n">girvan_newman</span><span class="p">(</span><span class="n">G</span><span class="p">)</span>

<span class="c1"># Output the best modularity score</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Best Modularity:&quot;</span><span class="p">,</span> <span class="n">calculate_modularity</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">best_partition</span><span class="p">))</span>

<span class="n">unique_comms</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">best_partition</span><span class="o">.</span><span class="n">values</span><span class="p">()))</span>
<span class="n">comm_colors</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">cm</span><span class="o">.</span><span class="n">tab20b</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="n">unique_comms</span><span class="p">)))</span>
<span class="n">comm_color_dict</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">unique_comms</span><span class="p">,</span> <span class="n">comm_colors</span><span class="p">))</span>

<span class="n">node_colors</span> <span class="o">=</span> <span class="p">[</span><span class="n">comm_color_dict</span><span class="p">[</span><span class="n">best_partition</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">K</span><span class="o">.</span><span class="n">nodes</span><span class="p">]</span>

<span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">7</span><span class="p">,</span><span class="mi">5</span><span class="p">),</span><span class="n">dpi</span><span class="o">=</span><span class="mi">100</span><span class="p">)</span>

<span class="n">nx</span><span class="o">.</span><span class="n">draw</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">pos</span><span class="o">=</span><span class="n">pos</span><span class="p">,</span> <span class="n">node_color</span><span class="o">=</span><span class="n">node_colors</span><span class="p">,</span> <span class="n">with_labels</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">ax</span><span class="o">=</span><span class="n">ax</span><span class="p">)</span>

<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Best Modularity: 0.3849721706864564
</pre></div>
</div>
<img alt="../../_images/3f486259da842d99ff690d273aa914438f56dd175700266ccecae5631222c8b2.png" src="../../_images/3f486259da842d99ff690d273aa914438f56dd175700266ccecae5631222c8b2.png" />
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span><span class="w"> </span><span class="nn">itertools</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">it</span>
<span class="n">w</span> <span class="o">=</span> <span class="mf">5.0</span>
<span class="n">h</span> <span class="o">=</span> <span class="mf">4.0</span>
<span class="n">nrows</span> <span class="o">=</span> <span class="mi">6</span>
<span class="n">ncols</span> <span class="o">=</span> <span class="mi">6</span>
<span class="n">tups</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">it</span><span class="o">.</span><span class="n">product</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">nrows</span><span class="p">),</span> <span class="nb">range</span><span class="p">(</span><span class="n">ncols</span><span class="p">)))</span>

<span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="n">nrows</span><span class="p">,</span> <span class="n">ncols</span><span class="p">,</span> <span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="n">w</span><span class="o">*</span><span class="n">ncols</span><span class="p">,</span><span class="n">h</span><span class="o">*</span><span class="n">nrows</span><span class="p">),</span> <span class="n">dpi</span><span class="o">=</span><span class="mi">150</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">subplots_adjust</span><span class="p">(</span><span class="n">wspace</span><span class="o">=</span><span class="mf">0.2</span><span class="p">,</span> <span class="n">hspace</span><span class="o">=</span><span class="mf">0.4</span><span class="p">)</span>


<span class="n">gn</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">nx</span><span class="o">.</span><span class="n">community</span><span class="o">.</span><span class="n">girvan_newman</span><span class="p">(</span><span class="n">G</span><span class="p">))</span>
<span class="n">best_partition</span> <span class="o">=</span> <span class="p">{</span><span class="n">i</span><span class="p">:</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="p">()}</span>
<span class="n">best_modularity</span> <span class="o">=</span> <span class="mi">0</span>
<span class="n">mods</span> <span class="o">=</span> <span class="p">[</span><span class="mf">0.0</span><span class="p">]</span>

<span class="k">for</span> <span class="n">ii</span><span class="p">,</span><span class="n">gn_i</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">gn</span><span class="p">):</span>
    <span class="n">part_i</span> <span class="o">=</span> <span class="p">{</span><span class="n">i</span><span class="p">:</span><span class="mi">0</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="p">()}</span>
    <span class="n">node_comms_i</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">gn_i</span><span class="p">)</span>
    <span class="n">ncomms_i</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">node_comms_i</span><span class="p">)))</span>
    <span class="k">for</span> <span class="n">ix</span><span class="p">,</span> <span class="n">p_i</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">gn_i</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">v_i</span> <span class="ow">in</span> <span class="n">p_i</span><span class="p">:</span>
            <span class="n">part_i</span><span class="p">[</span><span class="n">v_i</span><span class="p">]</span> <span class="o">=</span> <span class="n">ncomms_i</span><span class="p">[</span><span class="n">ix</span><span class="p">]</span>

    <span class="n">mod_i</span> <span class="o">=</span> <span class="n">calculate_modularity</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">part_i</span><span class="p">)</span>
    <span class="n">mods</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">mod_i</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">mod_i</span> <span class="o">&gt;</span> <span class="n">best_modularity</span><span class="p">:</span>
        <span class="n">best_partition</span> <span class="o">=</span> <span class="n">part_i</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">best_modularity</span> <span class="o">=</span> <span class="n">mod_i</span>

    <span class="n">unique_comms</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">part_i</span><span class="o">.</span><span class="n">values</span><span class="p">()))</span>
    <span class="n">comm_colors</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">cm</span><span class="o">.</span><span class="n">tab20b</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="n">unique_comms</span><span class="p">)))</span>
    <span class="n">comm_color_dict</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">unique_comms</span><span class="p">,</span> <span class="n">comm_colors</span><span class="p">))</span>

    <span class="n">node_colors</span> <span class="o">=</span> <span class="p">[</span><span class="n">comm_color_dict</span><span class="p">[</span><span class="n">part_i</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="p">]</span>
    <span class="n">nx</span><span class="o">.</span><span class="n">draw</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">pos</span><span class="p">,</span> <span class="n">node_color</span><span class="o">=</span><span class="n">node_colors</span><span class="p">,</span> <span class="n">node_size</span><span class="o">=</span><span class="mi">150</span><span class="p">,</span>
            <span class="n">ax</span><span class="o">=</span><span class="n">ax</span><span class="p">[</span><span class="n">tups</span><span class="p">[</span><span class="n">ii</span><span class="o">+</span><span class="mi">3</span><span class="p">]])</span>
    
    <span class="n">ax</span><span class="p">[</span><span class="n">tups</span><span class="p">[</span><span class="n">ii</span><span class="o">+</span><span class="mi">3</span><span class="p">]]</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s1">&#39;Iteration: </span><span class="si">%i</span><span class="s1">; Modularity: </span><span class="si">%.4f</span><span class="s1">&#39;</span><span class="o">%</span><span class="p">(</span><span class="n">ii</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">mod_i</span><span class="p">),</span>
                             <span class="n">fontsize</span><span class="o">=</span><span class="s1">&#39;x-large&#39;</span><span class="p">)</span>



<span class="n">ax</span><span class="p">[</span><span class="n">tups</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">mods</span><span class="p">)</span><span class="o">+</span><span class="mi">3</span><span class="p">]]</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s1">&#39;Iteration: </span><span class="si">%i</span><span class="s1">; Modularity: </span><span class="si">%.4f</span><span class="s1">&#39;</span><span class="o">%</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">mods</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">best_modularity</span><span class="p">),</span>
                         <span class="n">fontsize</span><span class="o">=</span><span class="s1">&#39;x-large&#39;</span><span class="p">,</span> <span class="n">fontweight</span><span class="o">=</span><span class="s1">&#39;bold&#39;</span><span class="p">)</span>
    

<span class="n">ax</span><span class="p">[</span><span class="n">tups</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span><span class="o">.</span><span class="n">text</span><span class="p">(</span><span class="mf">0.5</span><span class="p">,</span><span class="mf">0.5</span><span class="p">,</span><span class="s1">&#39;Illustration of</span><span class="se">\n</span><span class="s1">Girvan Newman</span><span class="se">\n</span><span class="s1">approach&#39;</span><span class="p">,</span>
                 <span class="n">ha</span><span class="o">=</span><span class="s1">&#39;center&#39;</span><span class="p">,</span><span class="n">va</span><span class="o">=</span><span class="s1">&#39;center&#39;</span><span class="p">,</span><span class="n">fontsize</span><span class="o">=</span><span class="s1">&#39;xx-large&#39;</span><span class="p">)</span>
<span class="n">ax</span><span class="p">[</span><span class="n">tups</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span><span class="o">.</span><span class="n">set_xlim</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
<span class="n">ax</span><span class="p">[</span><span class="n">tups</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span><span class="o">.</span><span class="n">set_ylim</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
<span class="n">ax</span><span class="p">[</span><span class="n">tups</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span><span class="o">.</span><span class="n">set_axis_off</span><span class="p">()</span>

<span class="n">ax</span><span class="p">[</span><span class="n">tups</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">mods</span><span class="p">,</span> <span class="n">lw</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;.2&#39;</span><span class="p">)</span>
<span class="n">ax</span><span class="p">[</span><span class="n">tups</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s1">&#39;Partition ID&#39;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="s1">&#39;x-large&#39;</span><span class="p">)</span>
<span class="n">ax</span><span class="p">[</span><span class="n">tups</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s1">&#39;Modularity&#39;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="s1">&#39;x-large&#39;</span><span class="p">)</span>

<span class="n">ax</span><span class="p">[</span><span class="n">tups</span><span class="p">[</span><span class="mi">2</span><span class="p">]]</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s1">&#39;Iteration: </span><span class="si">%i</span><span class="s1">; Modularity: </span><span class="si">%.4f</span><span class="s1">&#39;</span><span class="o">%</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mf">0.0</span><span class="p">),</span>
                             <span class="n">fontsize</span><span class="o">=</span><span class="s1">&#39;x-large&#39;</span><span class="p">)</span>
<span class="n">nx</span><span class="o">.</span><span class="n">draw</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">pos</span><span class="p">,</span> <span class="n">node_color</span><span class="o">=</span><span class="s1">&#39;.5&#39;</span><span class="p">,</span> <span class="n">node_size</span><span class="o">=</span><span class="mi">150</span><span class="p">,</span>
        <span class="n">ax</span><span class="o">=</span><span class="n">ax</span><span class="p">[</span><span class="n">tups</span><span class="p">[</span><span class="mi">2</span><span class="p">]])</span>
<span class="n">ax</span><span class="p">[</span><span class="n">tups</span><span class="p">[</span><span class="mi">2</span><span class="p">]]</span><span class="o">.</span><span class="n">set_axis_off</span><span class="p">()</span>

    

<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="../../_images/6f1bfc12877d35b71c7cb5be3f9eccc293c5baa111845f40f5643fab2c904fac.png" src="../../_images/6f1bfc12877d35b71c7cb5be3f9eccc293c5baa111845f40f5643fab2c904fac.png" />
</div>
</div>
<hr class="docutils" />
<section id="id1">
<h3>Challenges in Community Detection<a class="headerlink" href="#id1" title="Link to this heading">#</a></h3>
<p>Despite the wide use of community detection, several challenges persist:</p>
<ul class="simple">
<li><p><strong>Resolution Limit</strong>: Modularity-based methods can fail to detect small communities due to the resolution limit, where small but dense communities might be merged into larger ones.</p></li>
<li><p><strong>Overlapping Communities</strong>: Many real-world networks contain overlapping communities (e.g., a person belonging to multiple social groups), but traditional algorithms are typically designed to find disjoint partitions.</p></li>
<li><p><strong>Computational Complexity</strong>: For very large networks, many algorithms become computationally prohibitive. Efficient approximations or parallel implementations are often required.</p></li>
<li><p><strong>Ground Truth Validation</strong>: In many networks, the “ground truth” community structure is unknown, making it difficult to validate or compare different community detection methods.</p></li>
</ul>
<hr class="docutils" />
<section id="modularity-landscape">
<h4>Modularity Landscape<a class="headerlink" href="#modularity-landscape" title="Link to this heading">#</a></h4>
<p><img alt="" src="../../_images/good_montjoye_clauset.png" /></p>
<p>Figure: Low-dimensional visualization of the modularity landscape for the metabolic network of the <em>spirochete Treponema pallidum</em>. Partitions with high modularity have high <em>degeneracy</em>, which can be seen due to the large number of local maxima all with approximately the same modularity (see the red inset above the landscape). These modularity values in the “table top” of the landscape all are approximately equivalent to the maximum modularity, despite the fact that they correspond to different partitions. <em>Figure from Good, de Montjoye &amp; Clauset (2009)</em>.</p>
<p>Many heuristics give good estimates for the modularity maximization problem, however this can be due to the fact that there is an high degeneracy of large modularity partitions. This problem is particularly severe on graphs with hierarchical community structure (i.e. in many real world networks).</p>
<hr class="docutils" />
<p>Another problem is that having “high” modularity does not imply that the partitioning is good: i.e. random graphs might have high modularity even when there is no community structure in them. Indeed, in the standard modularity formulation we are only considering the average (i.e. expected) value of connections between nodes, but we are not considering possible fluctuations. One possible solution is to look at the <em><strong>z-score</strong></em> of the modularity value after having generated multiple realizations of the null model:</p>
<p>$$ Q_z = \frac{Q_{max} - \langle Q \rangle_{null}}{\sigma(Q)_{null}} $$</p>
</section>
</section>
</section>
<hr class="docutils" />
<section id="method-louvain-algorithm">
<h2>Method: Louvain Algorithm<a class="headerlink" href="#method-louvain-algorithm" title="Link to this heading">#</a></h2>
<p>In the years that followed the Girvan-Newman approach, we saw dozens of new community detection algorithms emerge. One that persisted for several years as a popular approach is called the <em><strong>Louvain Algorithn</strong></em> [1]. It is implemented as follows:</p>
<ol class="arabic simple">
<li><p><strong>Initialization:</strong> Each node starts as its own community.</p></li>
<li><p><strong>Phase 1 - Modularity Optimization:</strong></p></li>
</ol>
<ul class="simple">
<li><p>For each node $i$, the algorithm evaluates the gain in modularity from moving that node to each of its neighbors’ $j$ communities.</p></li>
<li><p>The node is placed in the community that maximizes the modularity gain. If no such move increases modularity, the node stays in its current community.</p></li>
</ul>
<ol class="arabic simple" start="3">
<li><p><strong>Phase 2 - Community Aggregation:</strong></p></li>
</ol>
<ul class="simple">
<li><p>Once no further modularity gains can be made, each community is collapsed into a single node, creating a new, smaller network.</p></li>
<li><p>The process repeats until modularity can no longer be improved.</p></li>
</ul>
<ol class="arabic simple" start="4">
<li><p><strong>Output:</strong> The algorithm outputs the community structure that maximizes the modularity.</p></li>
</ol>
<p><img alt="" src="../../_images/louvain.png" /></p>
<p>[1] Blondel, V. D., Guillaume, J. L., Lambiotte, R., &amp; Lefebvre, E. (2008). Fast unfolding of communities in large networks. Journal of Statistical Mechanics, 2008(10), P10008. https://doi.org/10.1088/1742-5468/2008/10/P10008</p>
<p><em><strong>Why it is efficient?</strong></em></p>
<p>$$ \Delta Q =  \left[ \frac{S_{C}^{in} + s_{i}^{in}}{2W} - \left( \frac{S_{C}^{tot} + s_{i}}{2W} \right)^2  \right]   -   \left[ \frac{S_{C}^{in}}{2W} - \left( \frac{S_{C}^{tot}}{2W} \right)^2 - \left( \frac{s_i}{2W} \right)^2  \right]  $$</p>
<p>where $s_i$ is the strength of node $i$, $s_{i,c}$ is the <em>internal</em> strength of node $i$,$S_{C}^{in} = \sum_{i \in C} s_{i}^{in}$ is the <em>internal</em> strength of cluster $C$, $S_{C}^{tot} = \sum_{i \in C} s_i$ is the total strength of cluster $C$, and $W$ is the sum of the weights of all the links in the network.</p>
<p>In practice, the complexity of this algorithm is approximagely $O(N \log N)$.</p>
<p>Below is an example of the (much more complicated!) functions involved in the Louvain method.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span><span class="w"> </span><span class="nn">networkx</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">nx</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">collections</span><span class="w"> </span><span class="kn">import</span> <span class="n">defaultdict</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">random</span><span class="w"> </span><span class="kn">import</span> <span class="n">shuffle</span>


<span class="k">def</span><span class="w"> </span><span class="nf">get_modularity</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">partition</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Calculate the modularity of the current partition of the graph G.</span>
<span class="sd">    </span>
<span class="sd">    Parameters:</span>
<span class="sd">    G (networkx.Graph): The graph for which modularity is to be calculated.</span>
<span class="sd">    partition (dict): A dictionary where keys are nodes and values are community labels.</span>

<span class="sd">    Returns:</span>
<span class="sd">    float: The modularity score for the given partition.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">E_c</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span>
    <span class="n">k_c</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span>
    
    <span class="n">M</span> <span class="o">=</span> <span class="mf">0.0</span>
    <span class="k">for</span> <span class="n">source_node</span><span class="p">,</span> <span class="n">target_node</span><span class="p">,</span> <span class="n">w</span> <span class="ow">in</span> <span class="n">G</span><span class="o">.</span><span class="n">edges</span><span class="p">(</span><span class="n">data</span> <span class="o">=</span> <span class="kc">True</span><span class="p">):</span>
        <span class="n">M</span> <span class="o">+=</span> <span class="n">w</span><span class="p">[</span><span class="s1">&#39;weight&#39;</span><span class="p">]</span> 
        <span class="k">if</span> <span class="n">partition</span><span class="p">[</span><span class="n">source_node</span><span class="p">]</span> <span class="o">==</span>  <span class="n">partition</span><span class="p">[</span><span class="n">target_node</span><span class="p">]:</span>
            <span class="n">E_c</span><span class="p">[</span><span class="n">partition</span><span class="p">[</span><span class="n">source_node</span><span class="p">]]</span> <span class="o">+=</span> <span class="n">w</span><span class="p">[</span><span class="s1">&#39;weight&#39;</span><span class="p">]</span>
    
    <span class="n">degrees</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">degree</span><span class="p">(</span><span class="n">weight</span><span class="o">=</span><span class="s1">&#39;weight&#39;</span><span class="p">)</span> 
    <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="p">():</span>
        <span class="n">k_c</span><span class="p">[</span><span class="n">partition</span><span class="p">[</span><span class="n">node</span><span class="p">]]</span> <span class="o">+=</span> <span class="n">degrees</span><span class="p">[</span><span class="n">node</span><span class="p">]</span>
        
    <span class="n">Q</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span> <span class="p">[</span> <span class="p">(</span><span class="n">E_c</span><span class="p">[</span><span class="n">c</span><span class="p">]</span><span class="o">/</span><span class="n">M</span><span class="p">)</span> <span class="o">-</span> <span class="p">(</span><span class="n">k_c</span><span class="p">[</span><span class="n">c</span><span class="p">]</span><span class="o">/</span><span class="p">(</span><span class="mf">2.0</span><span class="o">*</span><span class="n">M</span><span class="p">))</span><span class="o">**</span><span class="mi">2</span>   <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">k_c</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>     <span class="p">]</span>   <span class="p">)</span>
    <span class="k">return</span> <span class="n">Q</span>


<span class="k">def</span><span class="w"> </span><span class="nf">local_optimization_step</span><span class="p">(</span><span class="n">H</span><span class="p">,</span> <span class="n">Q_max</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Perform a local optimization step on the graph to maximize modularity by </span>
<span class="sd">    moving nodes to neighboring communities.</span>

<span class="sd">    Parameters:</span>
<span class="sd">    H (networkx.Graph): The graph with community assignments as node attributes.</span>
<span class="sd">    Q_max (float): The current maximum modularity.</span>
<span class="sd">    verbose (bool): If True, print the current iteration number.</span>

<span class="sd">    Returns:</span>
<span class="sd">    float: The updated maximum modularity after the optimization step.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">nodes</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">H</span><span class="o">.</span><span class="n">nodes</span><span class="p">())</span>
    <span class="n">shuffle</span><span class="p">(</span><span class="n">nodes</span><span class="p">)</span>

    <span class="n">something_changed</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="n">iteration</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="k">while</span> <span class="n">something_changed</span><span class="p">:</span>
        <span class="n">iteration</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Iteration: </span><span class="si">{</span><span class="n">iteration</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
        
        <span class="n">something_changed</span> <span class="o">=</span> <span class="kc">False</span>  <span class="c1"># Reset flag for changes made this iteration</span>
        
        <span class="k">for</span> <span class="n">node_i</span> <span class="ow">in</span> <span class="n">nodes</span><span class="p">:</span>
            <span class="n">current_partition</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">get_node_attributes</span><span class="p">(</span><span class="n">H</span><span class="p">,</span> <span class="s1">&#39;community&#39;</span><span class="p">)</span>
            <span class="n">current_community</span> <span class="o">=</span> <span class="n">current_partition</span><span class="p">[</span><span class="n">node_i</span><span class="p">]</span>
            <span class="n">best_community</span> <span class="o">=</span> <span class="n">current_community</span>
            <span class="n">best_diffQ</span> <span class="o">=</span> <span class="mi">0</span>
            
            <span class="c1"># Calculate the modularity change for moving node to each neighbor&#39;s community</span>
            <span class="k">for</span> <span class="n">neighbor</span> <span class="ow">in</span> <span class="n">H</span><span class="o">.</span><span class="n">neighbors</span><span class="p">(</span><span class="n">node_i</span><span class="p">):</span>
                <span class="n">neighbor_community</span> <span class="o">=</span> <span class="n">H</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">neighbor</span><span class="p">][</span><span class="s1">&#39;community&#39;</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">neighbor_community</span> <span class="o">!=</span> <span class="n">current_community</span><span class="p">:</span>  <span class="c1"># Only move if different</span>
                    <span class="n">current_partition</span><span class="p">[</span><span class="n">node_i</span><span class="p">]</span> <span class="o">=</span> <span class="n">neighbor_community</span>  <span class="c1"># Temporarily move</span>
                    <span class="n">Q_current</span> <span class="o">=</span> <span class="n">get_modularity</span><span class="p">(</span><span class="n">H</span><span class="p">,</span> <span class="n">current_partition</span><span class="p">)</span>
                    <span class="n">diffQ</span> <span class="o">=</span> <span class="n">Q_current</span> <span class="o">-</span> <span class="n">Q_max</span>

                    <span class="k">if</span> <span class="n">diffQ</span> <span class="o">&gt;</span> <span class="n">best_diffQ</span><span class="p">:</span>
                        <span class="n">best_diffQ</span> <span class="o">=</span> <span class="n">diffQ</span>
                        <span class="n">best_community</span> <span class="o">=</span> <span class="n">neighbor_community</span>

            <span class="c1"># Apply the best community change if it improves modularity</span>
            <span class="k">if</span> <span class="n">best_community</span> <span class="o">!=</span> <span class="n">current_community</span><span class="p">:</span>
                <span class="n">H</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">node_i</span><span class="p">][</span><span class="s1">&#39;community&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">best_community</span>
                <span class="n">Q_max</span> <span class="o">+=</span> <span class="n">best_diffQ</span>
                <span class="n">something_changed</span> <span class="o">=</span> <span class="kc">True</span>
        
        <span class="n">shuffle</span><span class="p">(</span><span class="n">nodes</span><span class="p">)</span>  <span class="c1"># Shuffle nodes for the next iteration</span>

    <span class="k">return</span> <span class="n">Q_max</span>


<span class="k">def</span><span class="w"> </span><span class="nf">network_aggregation_step</span><span class="p">(</span><span class="n">H</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Perform the network aggregation step by collapsing communities into super-nodes </span>
<span class="sd">    and recalculating edge weights between communities.</span>

<span class="sd">    Parameters:</span>
<span class="sd">    H (networkx.Graph): The graph where each node has a &#39;community&#39; attribute.</span>

<span class="sd">    Returns:</span>
<span class="sd">    networkx.Graph: A new graph where nodes represent communities from the previous step.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">edges</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span>  <span class="c1"># Dictionary to store new edges between communities</span>

    <span class="c1"># Aggregate edges between communities</span>
    <span class="k">for</span> <span class="n">source_node</span><span class="p">,</span> <span class="n">target_node</span><span class="p">,</span> <span class="n">w</span> <span class="ow">in</span> <span class="n">H</span><span class="o">.</span><span class="n">edges</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="n">c1</span> <span class="o">=</span> <span class="n">H</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">source_node</span><span class="p">][</span><span class="s1">&#39;community&#39;</span><span class="p">]</span>
        <span class="n">c2</span> <span class="o">=</span> <span class="n">H</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">target_node</span><span class="p">][</span><span class="s1">&#39;community&#39;</span><span class="p">]</span>

        <span class="c1"># Sort communities to ensure consistent ordering</span>
        <span class="n">edge</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">sorted</span><span class="p">((</span><span class="n">c1</span><span class="p">,</span> <span class="n">c2</span><span class="p">)))</span>

        <span class="c1"># Sum the edge weights between communities</span>
        <span class="n">edges</span><span class="p">[</span><span class="n">edge</span><span class="p">]</span> <span class="o">+=</span> <span class="n">w</span><span class="p">[</span><span class="s1">&#39;weight&#39;</span><span class="p">]</span>

    <span class="c1"># Create a new aggregated graph where nodes are communities</span>
    <span class="n">H_new</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">Graph</span><span class="p">()</span>
    <span class="n">H_new</span><span class="o">.</span><span class="n">add_edges_from</span><span class="p">(</span><span class="n">edges</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
    <span class="n">nx</span><span class="o">.</span><span class="n">set_edge_attributes</span><span class="p">(</span><span class="n">H_new</span><span class="p">,</span> <span class="n">values</span><span class="o">=</span><span class="n">edges</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;weight&#39;</span><span class="p">)</span>

    <span class="c1"># Set the community attribute of each node to itself (each node is its own community initially)</span>
    <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">H_new</span><span class="o">.</span><span class="n">nodes</span><span class="p">():</span>
        <span class="n">H_new</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">node</span><span class="p">][</span><span class="s1">&#39;community&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">node</span>
    
    <span class="k">return</span> <span class="n">H_new</span>


<span class="k">def</span><span class="w"> </span><span class="nf">reindex_communities</span><span class="p">(</span><span class="n">partition</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Reindex the communities in the partition so that community labels are continuous.</span>

<span class="sd">    Parameters:</span>
<span class="sd">    partition (dict): A dictionary where keys are nodes and values are community labels.</span>

<span class="sd">    Returns:</span>
<span class="sd">    dict: A new partition where community labels are reindexed to start from 0.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Create a mapping from old community labels to new indices</span>
    <span class="n">new_index</span> <span class="o">=</span> <span class="p">{</span><span class="n">community</span><span class="p">:</span> <span class="n">c</span> <span class="k">for</span> <span class="n">c</span><span class="p">,</span> <span class="n">community</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">partition</span><span class="o">.</span><span class="n">values</span><span class="p">()))}</span>
    
    <span class="c1"># Reindex the partition using the new indices</span>
    <span class="n">partition</span> <span class="o">=</span> <span class="p">{</span><span class="n">node</span><span class="p">:</span> <span class="n">new_index</span><span class="p">[</span><span class="n">community</span><span class="p">]</span> <span class="k">for</span> <span class="n">node</span><span class="p">,</span> <span class="n">community</span> <span class="ow">in</span> <span class="n">partition</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span>
    
    <span class="k">return</span> <span class="n">partition</span>


<span class="k">def</span><span class="w"> </span><span class="nf">louvain_method</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">init</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Run the Louvain method for community detection on a graph.</span>

<span class="sd">    Parameters:</span>
<span class="sd">    G (networkx.Graph): The input graph where nodes and edges define the structure.</span>
<span class="sd">    init (dict): Optional initial partition. If None, each node is its own community.</span>

<span class="sd">    Returns:</span>
<span class="sd">    dict: The final partition of the graph with node assignments to communities.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Make a copy of the graph to modify</span>
    <span class="n">H</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

    <span class="c1"># Initialize partition where each node is its own community, or use the provided initial partition</span>
    <span class="k">if</span> <span class="n">init</span><span class="p">:</span>
        <span class="n">best_partition</span> <span class="o">=</span> <span class="n">init</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">best_partition</span> <span class="o">=</span> <span class="p">{</span><span class="n">node</span><span class="p">:</span> <span class="n">c</span> <span class="k">for</span> <span class="n">c</span><span class="p">,</span> <span class="n">node</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">H</span><span class="o">.</span><span class="n">nodes</span><span class="p">())}</span>
    <span class="n">nx</span><span class="o">.</span><span class="n">set_node_attributes</span><span class="p">(</span><span class="n">H</span><span class="p">,</span> <span class="n">values</span><span class="o">=</span><span class="n">best_partition</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;community&#39;</span><span class="p">)</span>

    <span class="c1"># Map each community to its original set of nodes</span>
    <span class="n">aggregate_to_original</span> <span class="o">=</span> <span class="p">{</span><span class="n">node</span><span class="p">:</span> <span class="p">[</span><span class="n">node</span><span class="p">]</span> <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">H</span><span class="o">.</span><span class="n">nodes</span><span class="p">()}</span>

    <span class="c1"># Initialize edge weights if not present</span>
    <span class="n">weights</span> <span class="o">=</span> <span class="p">{(</span><span class="n">node_i</span><span class="p">,</span> <span class="n">node_j</span><span class="p">):</span> <span class="mf">1.0</span> <span class="k">for</span> <span class="n">node_i</span><span class="p">,</span> <span class="n">node_j</span> <span class="ow">in</span> <span class="n">H</span><span class="o">.</span><span class="n">edges</span><span class="p">()}</span>
    <span class="n">nx</span><span class="o">.</span><span class="n">set_edge_attributes</span><span class="p">(</span><span class="n">H</span><span class="p">,</span> <span class="n">values</span><span class="o">=</span><span class="n">weights</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;weight&#39;</span><span class="p">)</span>

    <span class="c1"># Compute initial modularity</span>
    <span class="n">Q_max</span> <span class="o">=</span> <span class="n">calculate_modularity</span><span class="p">(</span><span class="n">H</span><span class="p">,</span> <span class="n">best_partition</span><span class="p">)</span>

    <span class="n">N</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">H</span><span class="p">)</span>  <span class="c1"># Number of nodes (communities)</span>
    <span class="n">N_prev</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>  <span class="c1"># Previous number of communities</span>

    <span class="c1"># Main loop: optimize modularity and aggregate communities until no change</span>
    <span class="k">while</span> <span class="n">N</span> <span class="o">!=</span> <span class="n">N_prev</span><span class="p">:</span>
        <span class="c1"># 1) Perform local modularity optimization</span>
        <span class="n">Q_max</span> <span class="o">=</span> <span class="n">local_optimization_step</span><span class="p">(</span><span class="n">H</span><span class="p">,</span> <span class="n">Q_max</span><span class="p">)</span>

        <span class="c1"># Get the new community assignments after optimization</span>
        <span class="n">best_partition_aggregate</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">get_node_attributes</span><span class="p">(</span><span class="n">H</span><span class="p">,</span> <span class="s1">&#39;community&#39;</span><span class="p">)</span>

        <span class="c1"># Update the mapping from original nodes to new communities</span>
        <span class="n">aggregate_to_original_old</span> <span class="o">=</span> <span class="n">aggregate_to_original</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">aggregate_to_original</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">list</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">old_community</span><span class="p">,</span> <span class="n">new_community</span> <span class="ow">in</span> <span class="n">best_partition_aggregate</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">aggregate_to_original_old</span><span class="p">[</span><span class="n">old_community</span><span class="p">]:</span>
                <span class="n">aggregate_to_original</span><span class="p">[</span><span class="n">new_community</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
                <span class="n">best_partition</span><span class="p">[</span><span class="n">node</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_community</span>

        <span class="c1"># 2) Perform network aggregation to create a new graph</span>
        <span class="n">H</span> <span class="o">=</span> <span class="n">network_aggregation_step</span><span class="p">(</span><span class="n">H</span><span class="p">)</span>

        <span class="c1"># Update the number of nodes (communities)</span>
        <span class="n">N_prev</span> <span class="o">=</span> <span class="n">N</span>
        <span class="n">N</span> <span class="o">=</span> <span class="n">H</span><span class="o">.</span><span class="n">number_of_nodes</span><span class="p">()</span>

    <span class="c1"># Reindex the final community labels for clarity</span>
    <span class="n">best_partition</span> <span class="o">=</span> <span class="n">reindex_communities</span><span class="p">(</span><span class="n">best_partition</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">best_partition</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">G</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">karate_club_graph</span><span class="p">()</span>
<span class="n">partition</span> <span class="o">=</span> <span class="n">louvain_method</span><span class="p">(</span><span class="n">G</span><span class="p">)</span>

<span class="n">colors_sns</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">cm</span><span class="o">.</span><span class="n">tab20b</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">partition</span><span class="o">.</span><span class="n">values</span><span class="p">())))))</span>
<span class="n">colors_nodes</span> <span class="o">=</span> <span class="p">[</span><span class="n">colors_sns</span><span class="p">[</span><span class="n">partition</span><span class="p">[</span><span class="n">node</span><span class="p">]]</span> <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="p">()]</span>

<span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">7</span><span class="p">,</span><span class="mi">5</span><span class="p">),</span><span class="n">dpi</span><span class="o">=</span><span class="mi">100</span><span class="p">)</span>

<span class="n">nx</span><span class="o">.</span><span class="n">draw</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">pos</span><span class="o">=</span><span class="n">pos</span><span class="p">,</span> <span class="n">node_color</span><span class="o">=</span><span class="n">colors_nodes</span><span class="p">,</span> <span class="n">with_labels</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">ax</span><span class="o">=</span><span class="n">ax</span><span class="p">)</span>

<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="../../_images/e805797231bce8ff682ff657542b722aa159d12999162c71bf401cbba284ffdb.png" src="../../_images/e805797231bce8ff682ff657542b722aa159d12999162c71bf401cbba284ffdb.png" />
</div>
</div>
<hr class="docutils" />
<section id="community-detection-package-s">
<h3>Community detection package(s)<a class="headerlink" href="#community-detection-package-s" title="Link to this heading">#</a></h3>
<p>The Louvain algorithm is also implemented in this <code class="docutils literal notranslate"><span class="pre">community</span></code> Python package.</p>
<p>https://python-louvain.readthedocs.io/en/stable/index.html</p>
<p><code class="docutils literal notranslate"><span class="pre">import</span> <span class="pre">community</span></code></p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span><span class="w"> </span><span class="nn">community</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">G</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">karate_club_graph</span><span class="p">()</span>
<span class="n">partition</span> <span class="o">=</span> <span class="n">community</span><span class="o">.</span><span class="n">best_partition</span><span class="p">(</span><span class="n">G</span><span class="p">)</span>

<span class="n">colors_sns</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">cm</span><span class="o">.</span><span class="n">tab20b</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">partition</span><span class="o">.</span><span class="n">values</span><span class="p">())))))</span>
<span class="n">colors_nodes</span> <span class="o">=</span> <span class="p">[</span><span class="n">colors_sns</span><span class="p">[</span><span class="n">partition</span><span class="p">[</span><span class="n">node</span><span class="p">]]</span> <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="p">()]</span>

<span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">7</span><span class="p">,</span><span class="mi">5</span><span class="p">),</span><span class="n">dpi</span><span class="o">=</span><span class="mi">100</span><span class="p">)</span>

<span class="n">nx</span><span class="o">.</span><span class="n">draw</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">pos</span><span class="o">=</span><span class="n">pos</span><span class="p">,</span> <span class="n">node_color</span><span class="o">=</span><span class="n">colors_nodes</span><span class="p">,</span> <span class="n">with_labels</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">ax</span><span class="o">=</span><span class="n">ax</span><span class="p">)</span>

<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="../../_images/849738d48bcddd73bda8354ae192e04b29b67cbf8e7a33af05276d74e6643c8b.png" src="../../_images/849738d48bcddd73bda8354ae192e04b29b67cbf8e7a33af05276d74e6643c8b.png" />
</div>
</div>
</section>
</section>
<hr class="docutils" />
<section id="other-common-algorithms">
<h2>Other common algorithms<a class="headerlink" href="#other-common-algorithms" title="Link to this heading">#</a></h2>
<section id="spectral-optimization">
<h3>1. Spectral Optimization<a class="headerlink" href="#spectral-optimization" title="Link to this heading">#</a></h3>
<p>Based on a modularity matrix:</p>
<p>$$ B_{i,j} = A_{i,j} - \frac{k_ik_j}{2M} $$</p>
<p>Then,</p>
<p>\begin{eqnarray}
Q &amp;=&amp; \frac{1}{2M} \sum_{i,j} \left( A_{i,j} - \frac{k_ik_j}{2M} \right) \delta(C_i,C_j) \
&amp;=&amp; \frac{1}{4M} \sum_{i,j} \left( A_{i,j} - \frac{k_ik_j}{2M} \right) (s_is_j + 1)  \
&amp;=&amp; \frac{1}{4M} \sum_{i,j} B_{i,j}s_is_j   \
&amp;=&amp; \frac{1}{4M} s^TBs
\end{eqnarray}</p>
<p>Notice that:</p>
<ol class="arabic simple">
<li><p>$ \dfrac{s_is_j + 1}{2} $ is equal to 1 if $i$ and $j$ belong to the same community, 0 otherwise.</p></li>
<li><p>$ \sum_{i,j}A_{i,j} = \sum_{i}k_{i} = 2M $.</p></li>
</ol>
<p>Matrix $B$ is <em><strong>symmetric</strong></em> and it has $N$ orthonormal eigenvectors. Then, it can be shown that the previous equation can be rewritten as:</p>
<p>$$ Q = \frac{1}{4M} \sum_{i} \left( u_i^Ts \right)^2\lambda_i ,$$</p>
<p>where $u_i$ is an eigenvector of $B$ associated to the eigenvalue $\lambda_i$.</p>
<p>Therefore, the modularity maximization consists in setting the values of $s$ as to maximize the contribution of the leading eigenvalue (i.e. $\lambda_1$) of $B$.</p>
<p>Under the constraint that the entries of $s$ have to be either $+1$ or $-1$, we can find the optimal graph partitioning by setting $s_i = 1$ if $u_i &gt; 0$; $s_i = -1$, otherwise.</p>
</section>
<section id="infomap">
<h3>2. Infomap<a class="headerlink" href="#infomap" title="Link to this heading">#</a></h3>
<p>This is an <em><strong>information theoretic approach</strong></em> that reveals community structure in weighted and directed networks. The main idea is to find the best compressed description of the path of a random walker traversing the graph.</p>
<p>In practice, we want to minimize the <em><strong>map equation</strong></em>:</p>
<p>$$ L(M) = q_{between}H(\mathbb{L}) + \sum_{i=1}^m p_{within}^iH(\mathbb{P}^i) ,$$</p>
<p>where $q_{between}$ is the probability that the random walker moves in a different module at each step, $p_{within}^i$ is the probability that the random walker next step will be within the same module $i$, $H(x)$ denotes the <em>entropy</em> of the codewords used to describe $x$ using <em>Huffman coding</em> (https://en.wikipedia.org/wiki/Huffman_coding).</p>
<p><img alt="" src="../../_images/infomap.png" /></p>
<p>[1] Rosvall, M., &amp; Bergstrom, C.T. (2008). Maps of random walks on complex networks reveal community structure. Proceedings of the National Academy of Sciences, 105(4), 1118-1123. https://doi.org/10.1073/pnas.0706851105</p>
</section>
<section id="your-turn">
<h3>3. Your turn!<a class="headerlink" href="#your-turn" title="Link to this heading">#</a></h3>
<p>In the remaining time, it’s your chance to do a short mini-lit review. Find a community detection algorithm by searching google scholar. See if you can quickly skim through any descriptions you find on it to answer the following:</p>
<ul class="simple">
<li><p>What measure is being optimized (i.e., how do we know a given partition is optimal—or even good—under this approach?)</p></li>
<li><p>Algorithmically, how are partitions selected/sampled?</p></li>
<li><p>When did this technique come out? How many citations does it have?</p></li>
</ul>
</section>
</section>
<hr class="docutils" />
<section id="punchline-these-methods-all-have-a-common-failing">
<h2>Punchline: These methods all have a common failing<a class="headerlink" href="#punchline-these-methods-all-have-a-common-failing" title="Link to this heading">#</a></h2>
<p>… and it’s the topic of our next lesson!</p>
</section>
<hr class="docutils" />
<section id="next-time">
<h2>Next time…<a class="headerlink" href="#next-time" title="Link to this heading">#</a></h2>
<p>Clustering &amp; Community Detection 2 — Contemporary! <code class="docutils literal notranslate"><span class="pre">class_09_communities2.ipynb</span></code></p>
</section>
<hr class="docutils" />
<section id="references-and-further-resources">
<h2>References and further resources:<a class="headerlink" href="#references-and-further-resources" title="Link to this heading">#</a></h2>
<ol class="arabic simple">
<li><p>Class Webpages</p>
<ul class="simple">
<li><p>Jupyter Book: https://network-science-data-and-models.github.io/phys7332_fa25/README.html</p></li>
<li><p>Github: https://github.com/network-science-data-and-models/phys7332_fa25/</p></li>
<li><p>Syllabus and course details: https://brennanklein.com/phys7332-fall25</p></li>
</ul>
</li>
<li><p>Fortunato, S. (2010). Community detection in graphs. <em>Physics Reports</em>, 486(3), 75-174. https://doi.org/10.1016/j.physrep.2009.11.002</p></li>
<li><p>Fortunato, S., &amp; Hric, D. (2016). Community detection in networks: A user guide. <em>Physics Reports</em>, 659, 1-44. https://doi.org/10.1016/j.physrep.2016.09.002</p></li>
<li><p>Chakraborty, T., Dalmia, A., Mukherjee, A., &amp; Ganguly, N. (2017). Metrics for community analysis: A survey. <em>ACM Computing Surveys (CSUR)</em>, 50(4), 1-37. https://dl.acm.org/doi/10.1145/3091106</p></li>
<li><p>Good, B. H., De Montjoye, Y. A., &amp; Clauset, A. (2010). Performance of modularity maximization in practical contexts. <em>Physical Review E</em>, 81(4), 046106. https://link.aps.org/doi/10.1103/PhysRevE.81.046106</p></li>
<li><p>Girvan M. &amp; Newman M.E.J. (2002). Community structure in social and biological networks. Proceedings of the National Academy of Sciences, 99, 7821–7826. https://doi.org/10.1073/pnas.122653799</p></li>
<li><p>Newman, M.E.J., &amp; Girvan, M. (2004). “Finding and evaluating community structure in networks.” <em>Physical Review E</em>, 69(2), 026113. https://doi.org/10.1103/PhysRevE.69.026113</p></li>
<li><p>Rosvall, M. &amp; Bergstrom, C.T. (2008). Maps of random walks on complex networks reveal community structure. <em>Proceedings of the National Academy of Sciences</em>, 105(4), 1118-1123. https://doi.org/10.1073/pnas.0706851105</p></li>
<li><p>Blondel, V. D., Guillaume, J. L., Lambiotte, R., &amp; Lefebvre, E. (2008). Fast unfolding of communities in large networks. Journal of Statistical Mechanics, 2008(10), P10008. https://doi.org/10.1088/1742-5468/2008/10/P10008</p></li>
</ol>
</section>
</section>

    <script type="text/x-thebe-config">
    {
        requestKernel: true,
        binderOptions: {
            repo: "binder-examples/jupyter-stacks-datascience",
            ref: "master",
        },
        codeMirrorConfig: {
            theme: "abcdef",
            mode: "python"
        },
        kernelOptions: {
            name: "python3",
            path: "./notebooks/class_08"
        },
        predefinedOutput: true
    }
    </script>
    <script>kernelName = 'python3'</script>

                </article>
              

              
              
              
              
                <footer class="prev-next-footer d-print-none">
                  
<div class="prev-next-area">
    <a class="left-prev"
       href="../class_07/class_07_creating_a_network_from_sql_tables.html"
       title="previous page">
      <i class="fa-solid fa-angle-left"></i>
      <div class="prev-next-info">
        <p class="prev-next-subtitle">previous</p>
        <p class="prev-next-title">Class 7: Data Science 2 — Querying SQL Tables for Network Construction</p>
      </div>
    </a>
    <a class="right-next"
       href="../class_09/class_09_communities2.html"
       title="next page">
      <div class="prev-next-info">
        <p class="prev-next-subtitle">next</p>
        <p class="prev-next-title">Class 09: Clustering &amp; Community Detection 2 — Contemporary</p>
      </div>
      <i class="fa-solid fa-angle-right"></i>
    </a>
</div>
                </footer>
              
            </div>
            
            
              
                <div class="bd-sidebar-secondary bd-toc"><div class="sidebar-secondary-items sidebar-secondary__inner">


  <div class="sidebar-secondary-item">
  <div class="page-toc tocsection onthispage">
    <i class="fa-solid fa-list"></i> Contents
  </div>
  <nav class="bd-toc-nav page-toc">
    <ul class="visible nav section-nav flex-column">
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#community-detection-in-networks">Community Detection in Networks</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#what-is-a-community">What is a Community?</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#mathematically">Mathematically:</a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#more-formal-definitions-of-communities">More Formal Definitions of Communities</a><ul class="nav section-nav flex-column">
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#a-clique">a. Clique:</a></li>
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#b-dense-subgraph">b. Dense Subgraph:</a></li>
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#c-conductance">c. Conductance:</a></li>
</ul>
</li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#applications-of-community-detection">Applications of Community Detection</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#types-of-communities">Types of Communities</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#modularity">Modularity</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#popular-community-detection-algorithms">Popular Community Detection Algorithms</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#girvan-newman-algorithm">1. <strong>Girvan-Newman Algorithm</strong>:</a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#louvain-method">2. <strong>Louvain Method</strong>:</a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#infomap-algorithm">3. <strong>Infomap Algorithm</strong>:</a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#spectral-clustering">4. <strong>Spectral Clustering</strong>:</a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#and-many-many-many-more">And many… many… many more…</a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#challenges-in-community-detection">Challenges in Community Detection</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#resolution-limit">Resolution Limit:</a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#overlapping-communities">Overlapping Communities:</a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dynamic-and-evolving-communities">Dynamic and Evolving Communities:</a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#computational-complexity">Computational Complexity:</a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#examples-of-advanced-topics-in-community-detection">Examples of Advanced Topics in Community Detection</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#stochastic-block-models-sbm">Stochastic Block Models (SBM):</a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#label-propagation">Label Propagation:</a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#multi-layer-and-multiplex-networks">Multi-layer and Multiplex Networks:</a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#the-original-karate-club-viz">The Original Karate Club Viz</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#coding-modularity">Coding Modularity</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#method-girvan-newman">Method: Girvan Newman</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id1">Challenges in Community Detection</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#modularity-landscape">Modularity Landscape</a></li>
</ul>
</li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#method-louvain-algorithm">Method: Louvain Algorithm</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#community-detection-package-s">Community detection package(s)</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#other-common-algorithms">Other common algorithms</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#spectral-optimization">1. Spectral Optimization</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#infomap">2. Infomap</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#your-turn">3. Your turn!</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#punchline-these-methods-all-have-a-common-failing">Punchline: These methods all have a common failing</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#next-time">Next time…</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#references-and-further-resources">References and further resources:</a></li>
</ul>
  </nav></div>

</div></div>
              
            
          </div>
          <footer class="bd-footer-content">
            
<div class="bd-footer-content__inner container">
  
  <div class="footer-item">
    
<p class="component-author">
By Brennan Klein
</p>

  </div>
  
  <div class="footer-item">
    

  <p class="copyright">
    
      © Copyright 2023.
      <br/>
    
  </p>

  </div>
  
  <div class="footer-item">
    
  </div>
  
  <div class="footer-item">
    
  </div>
  
</div>
          </footer>
        

      </main>
    </div>
  </div>
  
  <!-- Scripts loaded after <body> so the DOM is not blocked -->
  <script src="../../_static/scripts/bootstrap.js?digest=dfe6caa3a7d634c4db9b"></script>
<script src="../../_static/scripts/pydata-sphinx-theme.js?digest=dfe6caa3a7d634c4db9b"></script>

  <footer class="bd-footer">
  </footer>
  </body>
</html>